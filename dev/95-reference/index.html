<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference Â· LevelSetMethods.jl</title><meta name="title" content="Reference Â· LevelSetMethods.jl"/><meta property="og:title" content="Reference Â· LevelSetMethods.jl"/><meta property="twitter:title" content="Reference Â· LevelSetMethods.jl"/><meta name="description" content="Documentation for LevelSetMethods.jl."/><meta property="og:description" content="Documentation for LevelSetMethods.jl."/><meta property="twitter:description" content="Documentation for LevelSetMethods.jl."/><meta property="og:url" content="https://maltezfaria.github.io/LevelSetMethods.jl/95-reference/"/><meta property="twitter:url" content="https://maltezfaria.github.io/LevelSetMethods.jl/95-reference/"/><link rel="canonical" href="https://maltezfaria.github.io/LevelSetMethods.jl/95-reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LevelSetMethods.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../terms/">Level-set terms</a></li><li><a class="tocitem" href="../time-integrators/">Time integration</a></li><li><a class="tocitem" href="../boundary-conditions/">Boundary conditions</a></li><li><span class="tocitem">Extensions</span><ul><li><a class="tocitem" href="../extension-makie/">Makie extension</a></li><li><a class="tocitem" href="../extension-mmg/">MMG extension</a></li><li><a class="tocitem" href="../extension-interpolations/">Interpolations extension</a></li><li><a class="tocitem" href="../extension-reinitialization/">Reinitialization</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example-zalesak/">Zalesak disk</a></li><li><a class="tocitem" href="../example-shape-optim/">Shape optimization: a primer</a></li></ul></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/main/docs/src/95-reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="reference"><a class="docs-heading-anchor" href="#reference">Reference</a><a id="reference-1"></a><a class="docs-heading-anchor-permalink" href="#reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LevelSetMethods.AbstractMesh"><code>LevelSetMethods.AbstractMesh</code></a></li><li><a href="#LevelSetMethods.AdvectionTerm"><code>LevelSetMethods.AdvectionTerm</code></a></li><li><a href="#LevelSetMethods.BoundaryCondition"><code>LevelSetMethods.BoundaryCondition</code></a></li><li><a href="#LevelSetMethods.CartesianGrid-Tuple{Any, Any, Any}"><code>LevelSetMethods.CartesianGrid</code></a></li><li><a href="#LevelSetMethods.CartesianMeshField"><code>LevelSetMethods.CartesianMeshField</code></a></li><li><a href="#LevelSetMethods.CurvatureTerm"><code>LevelSetMethods.CurvatureTerm</code></a></li><li><a href="#LevelSetMethods.DirichletBC"><code>LevelSetMethods.DirichletBC</code></a></li><li><a href="#LevelSetMethods.LevelSet"><code>LevelSetMethods.LevelSet</code></a></li><li><a href="#LevelSetMethods.LevelSetEquation-Tuple{}"><code>LevelSetMethods.LevelSetEquation</code></a></li><li><a href="#LevelSetMethods.LevelSetTerm"><code>LevelSetMethods.LevelSetTerm</code></a></li><li><a href="#LevelSetMethods.MeshField-Tuple{Function, Any}"><code>LevelSetMethods.MeshField</code></a></li><li><a href="#LevelSetMethods.MeshField"><code>LevelSetMethods.MeshField</code></a></li><li><a href="#LevelSetMethods.NeumannBC"><code>LevelSetMethods.NeumannBC</code></a></li><li><a href="#LevelSetMethods.NeumannGradientBC"><code>LevelSetMethods.NeumannGradientBC</code></a></li><li><a href="#LevelSetMethods.NormalMotionTerm"><code>LevelSetMethods.NormalMotionTerm</code></a></li><li><a href="#LevelSetMethods.PeriodicBC"><code>LevelSetMethods.PeriodicBC</code></a></li><li><a href="#LevelSetMethods.RK2"><code>LevelSetMethods.RK2</code></a></li><li><a href="#LevelSetMethods.RK3"><code>LevelSetMethods.RK3</code></a></li><li><a href="#LevelSetMethods.ReinitializationTerm"><code>LevelSetMethods.ReinitializationTerm</code></a></li><li><a href="#LevelSetMethods.Reinitializer"><code>LevelSetMethods.Reinitializer</code></a></li><li><a href="#LevelSetMethods.SemiImplicitI2OE"><code>LevelSetMethods.SemiImplicitI2OE</code></a></li><li><a href="#LevelSetMethods.TimeIntegrator"><code>LevelSetMethods.TimeIntegrator</code></a></li><li><a href="#LevelSetMethods.D2-Tuple{Any, Any, Any}"><code>LevelSetMethods.D2</code></a></li><li><a href="#LevelSetMethods.D2â°-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.D2â°</code></a></li><li><a href="#LevelSetMethods.D2âºâº-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.D2âºâº</code></a></li><li><a href="#LevelSetMethods.D2â»â»-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.D2â»â»</code></a></li><li><a href="#LevelSetMethods.Dâ°-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.Dâ°</code></a></li><li><a href="#LevelSetMethods.Dâº-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.Dâº</code></a></li><li><a href="#LevelSetMethods.Dâ»-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.Dâ»</code></a></li><li><a href="#LevelSetMethods.curvature-Tuple{LevelSet}"><code>LevelSetMethods.curvature</code></a></li><li><a href="#LevelSetMethods.curvature-Tuple{LevelSet, Any}"><code>LevelSetMethods.curvature</code></a></li><li><a href="#LevelSetMethods.export_surface_mesh-Tuple{LevelSet, String}"><code>LevelSetMethods.export_surface_mesh</code></a></li><li><a href="#LevelSetMethods.export_surface_mesh-Tuple{LevelSetEquation, Vararg{Any}}"><code>LevelSetMethods.export_surface_mesh</code></a></li><li><a href="#LevelSetMethods.export_volume_mesh-Tuple{LevelSet, String}"><code>LevelSetMethods.export_volume_mesh</code></a></li><li><a href="#LevelSetMethods.export_volume_mesh-Tuple{LevelSetEquation, Vararg{Any}}"><code>LevelSetMethods.export_volume_mesh</code></a></li><li><a href="#LevelSetMethods.extend_along_normals!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, LevelSet}} where {T&lt;:Real, N}"><code>LevelSetMethods.extend_along_normals!</code></a></li><li><a href="#LevelSetMethods.grad_norm-Tuple{LevelSet}"><code>LevelSetMethods.grad_norm</code></a></li><li><a href="#LevelSetMethods.gradient-Tuple{LevelSet, Any}"><code>LevelSetMethods.gradient</code></a></li><li><a href="#LevelSetMethods.hessian-Tuple{LevelSet, Any}"><code>LevelSetMethods.hessian</code></a></li><li><a href="#LevelSetMethods.integrate!"><code>LevelSetMethods.integrate!</code></a></li><li><a href="#LevelSetMethods.makie_theme"><code>LevelSetMethods.makie_theme</code></a></li><li><a href="#LevelSetMethods.normal-Tuple{LevelSet, Any}"><code>LevelSetMethods.normal</code></a></li><li><a href="#LevelSetMethods.normal-Tuple{LevelSet}"><code>LevelSetMethods.normal</code></a></li><li><a href="#LevelSetMethods.perimeter-Tuple{LevelSet}"><code>LevelSetMethods.perimeter</code></a></li><li><a href="#LevelSetMethods.reinitialize!-Tuple{Any, Any}"><code>LevelSetMethods.reinitialize!</code></a></li><li><a href="#LevelSetMethods.set_makie_theme!"><code>LevelSetMethods.set_makie_theme!</code></a></li><li><a href="#LevelSetMethods.update_term!-Tuple{LevelSetMethods.LevelSetTerm, Any, Any}"><code>LevelSetMethods.update_term!</code></a></li><li><a href="#LevelSetMethods.volume-Tuple{LevelSet}"><code>LevelSetMethods.volume</code></a></li></ul><article><details class="docstring" open="true"><summary id="LevelSetMethods.AbstractMesh"><a class="docstring-binding" href="#LevelSetMethods.AbstractMesh"><code>LevelSetMethods.AbstractMesh</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractMesh{N,T}</code></pre><p>An abstract mesh structure in dimension <code>N</code> with primite data of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/meshes.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.AdvectionTerm"><a class="docstring-binding" href="#LevelSetMethods.AdvectionTerm"><code>LevelSetMethods.AdvectionTerm</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AdvectionTerm(ğ®[, scheme = WENO5(), update_func = nothing])</code></pre><p>Advection term representing  <code>ğ® â‹… âˆ‡Ï•</code>. Available <code>scheme</code>s are <code>Upwind</code> and <code>WENO5</code>.</p><p>If passed, <code>update_func</code> will be called as <code>update_func(ğ®, Ï•, t)</code> before computing the term at each stage of the time evolution. This can be used to update the velocity field <code>ğ®</code> depending not only on <code>t</code>, but also on the current level set <code>Ï•</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetterms.jl#L35-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.BoundaryCondition"><a class="docstring-binding" href="#LevelSetMethods.BoundaryCondition"><code>LevelSetMethods.BoundaryCondition</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type BoundaryCondition</code></pre><p>Types used to specify boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/boundaryconditions.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.CartesianGrid-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.CartesianGrid-Tuple{Any, Any, Any}"><code>LevelSetMethods.CartesianGrid</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">CartesianGrid(lc, hc, n)</code></pre><p>Create a uniform cartesian grid with lower corner <code>lc</code>, upper corner <code>hc</code> and and <code>n</code> nodes in each direction.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using LevelSetMethods
a = (0, 0)
b = (1, 1)
n = (10, 4)
grid = CartesianGrid(a, b, n)

# output

CartesianGrid{2, Int64}([0, 0], [1, 1], (10, 4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/meshes.jl#L14-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.CartesianMeshField"><a class="docstring-binding" href="#LevelSetMethods.CartesianMeshField"><code>LevelSetMethods.CartesianMeshField</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">const CartesianMeshField{V,M&lt;:CartesianGrid} = MeshField{V,M}</code></pre><p><a href="#LevelSetMethods.MeshField"><code>MeshField</code></a> over a <a href="#LevelSetMethods.CartesianGrid-Tuple{Any, Any, Any}"><code>CartesianGrid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/meshfield.jl#L137-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.CurvatureTerm"><a class="docstring-binding" href="#LevelSetMethods.CurvatureTerm"><code>LevelSetMethods.CurvatureTerm</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CurvatureTerm{V,M} &lt;: LevelSetTerm</code></pre><p>Level-set curvature term representing <code>bÎº|âˆ‡Ï•|</code>, where <code>Îº = âˆ‡ â‹… (âˆ‡Ï•/|âˆ‡Ï•|)</code> is the curvature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetterms.jl#L103-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.DirichletBC"><a class="docstring-binding" href="#LevelSetMethods.DirichletBC"><code>LevelSetMethods.DirichletBC</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DirichletBC{T} &lt;: BoundaryCondition</code></pre><p>A Dirichlet boundary condition taking values of <code>f(x)</code> at the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/boundaryconditions.jl#L29-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.LevelSet"><a class="docstring-binding" href="#LevelSetMethods.LevelSet"><code>LevelSetMethods.LevelSet</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LevelSet</code></pre><p>Alias for <a href="#LevelSetMethods.MeshField"><code>MeshField</code></a> with <code>vals</code> as an <code>AbstractArray</code> of <code>Real</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.LevelSetEquation-Tuple{}"><a class="docstring-binding" href="#LevelSetMethods.LevelSetEquation-Tuple{}"><code>LevelSetMethods.LevelSetEquation</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LevelSetEquation(; terms, levelset, boundary_conditions, t = 0, integrator = RK2(),
reinit = nothing)</code></pre><p>Create a of a level-set equation of the form <code>Ï•â‚œ + sum(terms) = 0</code>, where each <code>t âˆˆ terms</code> is a <a href="#LevelSetMethods.LevelSetTerm"><code>LevelSetTerm</code></a> and <code>levelset</code> is the initial <a href="#LevelSetMethods.LevelSet"><code>LevelSet</code></a>.</p><p>Calling <a href="#LevelSetMethods.integrate!"><code>integrate!(ls, tf)</code></a> will evolve the level-set equation up to time <code>tf</code>, modifying the <code>current_state(eq)</code> and <code>current_time(eq)</code> of the object <code>eq</code> in the process (and therefore the original <code>levelset</code>).</p><p>Boundary conditions can be specified in two ways. If a single <code>BoundaryCondition</code> is provided, it will be applied uniformly to all boundaries of the domain. To apply different boundary conditions to each boundary, pass a tuple of the form <code>(bc_x, bc_y, ...)</code> with as many elements as dimensions in the domain. If <code>bc_x</code> is a <code>BoundaryCondition</code>, it will be applied to both boundaries in the <code>x</code> direction. If <code>bc_x</code> is a tuple of two <code>BoundaryCondition</code>s, the first will be applied to the left boundary and the second to the right boundary. The same logic applies to the other dimensions.</p><p>The optional parameter <code>t</code> specifies the initial time of the simulation, and <code>integrator</code> is the <a href="#LevelSetMethods.TimeIntegrator"><code>TimeIntegrator</code></a> used to evolve the level-set equation.</p><p>Reinitialization of the level-set function is controlled by the <code>reinit</code> parameter, a <a href="#LevelSetMethods.Reinitializer"><code>Reinitializer</code></a> object that specifies both the reinitialization algorithm parameters and the frequency (in time steps). By default, no automatic reinitialization is performed. Using this feature requires the <code>ReinitializationExt</code> to be loaded.</p><pre><code class="language-julia hljs">using LevelSetMethods, StaticArrays
grid = CartesianGrid((-1, -1), (1, 1), (50, 50))    # define the grid
Ï• = LevelSet(x -&gt; x[1]^2 + x[2]^2 - 0.5^2, grid)    # initial shape
ğ® = MeshField(x -&gt; SVector(1, 0), grid)             # advection velocity
terms = (AdvectionTerm(ğ®),)            # advection and curvature terms
bc = PeriodicBC()                                   # periodic boundary conditions
eq = LevelSetEquation(; terms, levelset = Ï•, bc)    # level-set equation

# output

Level-set equation given by

 	 Ï•â‚œ + ğ® â‹… âˆ‡ Ï• = 0

Current time 0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetequation.jl#L10-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.LevelSetTerm"><a class="docstring-binding" href="#LevelSetMethods.LevelSetTerm"><code>LevelSetMethods.LevelSetTerm</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type LevelSetTerm</code></pre><p>A typical term in a level-set evolution equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetterms.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.MeshField"><a class="docstring-binding" href="#LevelSetMethods.MeshField"><code>LevelSetMethods.MeshField</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MeshField{V,M,B}</code></pre><p>A field described by its discrete values on a mesh.</p><p><code>Base.getindex</code> of an <code>MeshField</code> is overloaded to handle indices that lie outside the <code>CartesianIndices</code> of its <code>MeshField</code> by using <code>bcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/meshfield.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.MeshField-Tuple{Function, Any}"><a class="docstring-binding" href="#LevelSetMethods.MeshField-Tuple{Function, Any}"><code>LevelSetMethods.MeshField</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MeshField(f::Function, m)</code></pre><p>Create a <code>MeshField</code> by evaluating a function <code>f</code> on a mesh <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/meshfield.jl#L26-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.NeumannBC"><a class="docstring-binding" href="#LevelSetMethods.NeumannBC"><code>LevelSetMethods.NeumannBC</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NeumannBC &lt;: BoundaryCondition</code></pre><p>Homogenous Neumann boundary condition, i.e. âˆ‚x Ï• = 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/boundaryconditions.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.NeumannGradientBC"><a class="docstring-binding" href="#LevelSetMethods.NeumannGradientBC"><code>LevelSetMethods.NeumannGradientBC</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NeumannGradientBC &lt;: BoundaryCondition</code></pre><p>Homogenous Neumann gradient boundary condition, i.e. âˆ‚xx Ï• = 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/boundaryconditions.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.NormalMotionTerm"><a class="docstring-binding" href="#LevelSetMethods.NormalMotionTerm"><code>LevelSetMethods.NormalMotionTerm</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NormalMotionTerm{V,F} &lt;: LevelSetTerm</code></pre><p>Level-set advection term representing  <code>v |âˆ‡Ï•|</code>. This <code>LevelSetTerm</code> should be used for internally generated velocity fields; for externally generated velocities you may use <code>AdvectionTerm</code> instead.</p><p>If passed, <code>update_func</code> will be called as <code>update_func(v, Ï•, t)</code> before computing the term at each stage of the time evolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetterms.jl#L150-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.PeriodicBC"><a class="docstring-binding" href="#LevelSetMethods.PeriodicBC"><code>LevelSetMethods.PeriodicBC</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PeriodicBC &lt;: BoundaryCondition</code></pre><p>Singleton type representing periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/boundaryconditions.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.RK2"><a class="docstring-binding" href="#LevelSetMethods.RK2"><code>LevelSetMethods.RK2</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct RK2</code></pre><p>Second order total variation dimishing Runge-Kutta scheme, also known as Heun&#39;s predictor-corrector method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/timestepping.jl#L14-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.RK3"><a class="docstring-binding" href="#LevelSetMethods.RK3"><code>LevelSetMethods.RK3</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct RK3</code></pre><p>Third order total variation dimishing Runge-Kutta scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/timestepping.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.ReinitializationTerm"><a class="docstring-binding" href="#LevelSetMethods.ReinitializationTerm"><code>LevelSetMethods.ReinitializationTerm</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ReinitializationTerm &lt;: LevelSetTerm</code></pre><p>Level-set term representing  <code>sign(Ï•) (|âˆ‡Ï•| - 1)</code>. This <code>LevelSetTerm</code> should be used for reinitializing the level set into a signed distance function: for a sufficiently large number of time steps this term allows one to solve the Eikonal equation |âˆ‡Ï•| = 1.</p><p>There are two ways of constructing a <code>ReinitializationTerm</code>:</p><ul><li>using <code>ReinitializationTerm(Ï•â‚€::LevelSet)</code> precomputes the <code>sign</code> term on the initial level set <code>Ï•â‚€</code>, as in equation 7.5 of Osher and Fedkiw;</li><li>using <code>ReinitializationTerm()</code> constructs a term that computes the <code>sign</code> term on-the-fly at each time step, as in equation 7.6 of Osher and Fedkiw.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetterms.jl#L236-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.Reinitializer"><a class="docstring-binding" href="#LevelSetMethods.Reinitializer"><code>LevelSetMethods.Reinitializer</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Reinitializer(; upsample=8, maxiters=20, xtol=1e-8, ftol=1e-8, reinit_freq=1)</code></pre><p>Configuration for Newton-based reinitialization to a signed distance function. The <code>reinit_freq</code> parameter specifies how often reinitialization is performed (in time steps).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/reinitializer.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.SemiImplicitI2OE"><a class="docstring-binding" href="#LevelSetMethods.SemiImplicitI2OE"><code>LevelSetMethods.SemiImplicitI2OE</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SemiImplicitI2OE</code></pre><p>Semi-implicit finite-volume scheme of the I2OE family (Mikula et al.) for advection problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/timestepping.jl#L36-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.TimeIntegrator"><a class="docstring-binding" href="#LevelSetMethods.TimeIntegrator"><code>LevelSetMethods.TimeIntegrator</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type TimeIntegrator end</code></pre><p>Abstract type for time integrators. See <code>subtypes(TimeIntegrator)</code> for a list of available time integrators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/timestepping.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.D2-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.D2-Tuple{Any, Any, Any}"><code>LevelSetMethods.D2</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">D2(Ï•::CartesianMeshField,I,dims)</code></pre><p>Finite difference scheme for second order derivative at grid point <code>I</code> along the dimensions <code>dims</code>.</p><p>If <code>dims[1] == dims[2]</code>, it is more efficient to call <code>D2â°(Ï•,I,dims[1])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/derivatives.jl#L137-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.D2â°-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.D2â°-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.D2â°</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">D2â°(Ï•::CartesianMeshField,I,dim)</code></pre><p>Centered finite difference scheme for second order derivative at grid point <code>I</code> along dimension <code>dim</code>. E.g. if <code>dim=1</code>, this approximates <code>âˆ‚â‚“â‚“</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/derivatives.jl#L124-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.D2âºâº-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.D2âºâº-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.D2âºâº</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">D2âºâº(Ï•::CartesianMeshField,I,dim)</code></pre><p>Upward finite difference scheme for second order derivative at grid point <code>I</code> along dimension <code>dim</code>. E.g. if <code>dim=1</code>, this approximates <code>âˆ‚â‚“â‚“</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/derivatives.jl#L152-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.D2â»â»-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.D2â»â»-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.D2â»â»</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">D2â»âº(Ï•::CartesianMeshField,I,dim)</code></pre><p>Backward finite difference scheme for second order derivative at grid point <code>I</code> along dimension <code>dim</code>. E.g. if <code>dim=1</code>, this approximates <code>âˆ‚â‚“â‚“</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/derivatives.jl#L165-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.Dâ°-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.Dâ°-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.Dâ°</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Dâ°(Ï•::CartesianMeshField,I,dim)</code></pre><p>Centered finite difference scheme for first order derivative at grid point <code>I</code> along dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/derivatives.jl#L7-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.Dâº-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.Dâº-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.Dâº</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Dâº(Ï•::CartesianMeshField,I,dim)</code></pre><p>Forward finite difference scheme for first order derivative at grid point <code>I</code> along dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/derivatives.jl#L20-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.Dâ»-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.Dâ»-Tuple{MeshField{V, M} where {V, M&lt;:CartesianGrid}, Any, Any}"><code>LevelSetMethods.Dâ»</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Dâ»(Ï•::CartesianMeshField,I,dim)</code></pre><p>Backward finite difference scheme for first order derivative at grid point <code>I</code> along dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/derivatives.jl#L39-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.curvature-Tuple{LevelSet, Any}"><a class="docstring-binding" href="#LevelSetMethods.curvature-Tuple{LevelSet, Any}"><code>LevelSetMethods.curvature</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">curvature(Ï•::LevelSet, I)</code></pre><p>Compute the mean curvature of Ï• at I using Îº = âˆ‡ â‹… (âˆ‡Ï• / |âˆ‡Ï•|). We use the formula Îº = (Î”Ï• |âˆ‡Ï•|^2 - âˆ‡Ï•^T HÏ• âˆ‡Ï•) / |âˆ‡Ï•|^3 with first order finite differences. https://en.wikipedia.org/wiki/Mean<em>curvature#Implicit</em>form<em>of</em>mean_curvature</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L105-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.curvature-Tuple{LevelSet}"><a class="docstring-binding" href="#LevelSetMethods.curvature-Tuple{LevelSet}"><code>LevelSetMethods.curvature</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">curvature(Ï•::LevelSet)</code></pre><p>Compute the mean curvature of Ï• at I using Îº = âˆ‡ â‹… (âˆ‡Ï• / |âˆ‡Ï•|). See <a href="#LevelSetMethods.curvature-Tuple{LevelSet, Any}"><code>curvature(Ï•::LevelSet, I)</code></a> for more details.</p><pre><code class="language-julia hljs">using LevelSetMethods
N = 50
grid = CartesianGrid((-1, -1), (1, 1), (N, N))
Ï• = LevelSetMethods.star(grid)
using GLMakie
coeff = exp.(-40.0 * values(Ï•) .^ 2)
Îº = curvature(Ï•) .* coeff
xs = LevelSetMethods.grid1d(grid, 1)
ys = LevelSetMethods.grid1d(grid, 2)
fig, ax, hm = heatmap(xs, ys, Îº)
Colorbar(fig[:, end+1], hm)
contour!(xs, ys, values(Ï•); levels = [0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L147-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.extend_along_normals!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, LevelSet}} where {T&lt;:Real, N}"><a class="docstring-binding" href="#LevelSetMethods.extend_along_normals!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, LevelSet}} where {T&lt;:Real, N}"><code>LevelSetMethods.extend_along_normals!</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extend_along_normals!(F, Ï•::LevelSet;
                      nb_iters = 50,
                      cfl = 0.45,
                      frozen = nothing,
                      interface_band = 1.5,
                      min_norm = 1e-14)</code></pre><p>Extend a scalar speed field <code>F</code> away from the interface of <code>Ï•</code> by solving in pseudo-time <code>âˆ‚Ï„F + sign(Ï•) nâ‹…âˆ‡F = 0</code>, with <code>n = âˆ‡Ï• / |âˆ‡Ï•|</code>.</p><p>The equation is discretized with first-order upwind derivatives. The update preserves <code>frozen</code> nodes (Dirichlet constraint). If <code>frozen</code> is not provided, a mask is built from the interface band <code>abs(Ï•) &lt;= interface_band * Î”</code>, where <code>Î” = minimum(meshsize(Ï•))</code>.</p><p><code>F</code> can be an <code>AbstractArray</code> (same size as <code>Ï•</code>) or a <code>MeshField</code> on the same mesh.</p><p>Reference from [Peng et al. 1999]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/velocityextension.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.grad_norm-Tuple{LevelSet}"><a class="docstring-binding" href="#LevelSetMethods.grad_norm-Tuple{LevelSet}"><code>LevelSetMethods.grad_norm</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grad_norm(Ï•::LevelSet[, I])</code></pre><p>Compute the norm of the gradient of Ï• at index <code>I</code>, i.e. <code>|âˆ‡Ï•|</code>, or for all grid points if <code>I</code> is not provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetequation.jl#L510-L515">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.gradient-Tuple{LevelSet, Any}"><a class="docstring-binding" href="#LevelSetMethods.gradient-Tuple{LevelSet, Any}"><code>LevelSetMethods.gradient</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gradient(Ï•::LevelSet, I)</code></pre><p>Return the gradient vector âˆ‡Ï• of Ï• at I</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L177-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.hessian-Tuple{LevelSet, Any}"><a class="docstring-binding" href="#LevelSetMethods.hessian-Tuple{LevelSet, Any}"><code>LevelSetMethods.hessian</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hessian(Ï•::LevelSet, I)</code></pre><p>Return the Hessian matrix HÏ• of Ï• at I</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L232-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.integrate!"><a class="docstring-binding" href="#LevelSetMethods.integrate!"><code>LevelSetMethods.integrate!</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">integrate!(ls::LevelSetEquation,tf,Î”t=Inf)</code></pre><p>Integrate the <a href="../#LevelSetMethods.LevelSetEquation"><code>LevelSetEquation</code></a> <code>ls</code> up to time <code>tf</code>, mutating the <code>levelset</code> and <code>current_time</code> of the object <code>ls</code> in the process.</p><p>An optional parameter <code>Î”t</code> can be passed to specify a maximum time-step allowed for the integration. Note that the internal time-steps taken to evolve the level-set up to <code>tf</code> may be smaller than <code>Î”t</code> due to stability reasons related to the <code>terms</code> and <code>integrator</code> employed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetequation.jl#L138-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.makie_theme"><a class="docstring-binding" href="#LevelSetMethods.makie_theme"><code>LevelSetMethods.makie_theme</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">makie_theme()</code></pre><p>Return a Makie theme for plots of level-set functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/LevelSetMethods.jl#L42-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.normal-Tuple{LevelSet, Any}"><a class="docstring-binding" href="#LevelSetMethods.normal-Tuple{LevelSet, Any}"><code>LevelSetMethods.normal</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">normal(Ï•::LevelSet, I)</code></pre><p>Compute the unit exterior normal vector of Ï• at I using n = âˆ‡Ï•/|âˆ‡Ï•|</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L191-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.normal-Tuple{LevelSet}"><a class="docstring-binding" href="#LevelSetMethods.normal-Tuple{LevelSet}"><code>LevelSetMethods.normal</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">normal(Ï•::LevelSet)</code></pre><p>Compute the unit exterior normal vector of Ï• using n = âˆ‡Ï•/|âˆ‡Ï•|</p><pre><code class="language-julia hljs">using LevelSetMethods
N = 50
grid = CartesianGrid((-1, -1), (1, 1), (N, N))
Ï• = LevelSetMethods.star(grid)
using GLMakie
n = normal(Ï•)
xs = LevelSetMethods.grid1d(grid, 1)
ys = LevelSetMethods.grid1d(grid, 2)
coeff = exp.(-40.0 * values(Ï•) .^ 2)
us = getindex.(n, 1) .* coeff
vs = getindex.(n, 2) .* coeff
arrows(xs, ys, us, vs; arrowsize = 10 * vec(coeff), lengthscale = 2.0 / (N - 1))
contour!(xs, ys, values(Ï•); levels = [0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L201-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.perimeter-Tuple{LevelSet}"><a class="docstring-binding" href="#LevelSetMethods.perimeter-Tuple{LevelSet}"><code>LevelSetMethods.perimeter</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">perimeter(Ï•::LevelSet)</code></pre><p>Compute the perimeter area of the level-set function.</p><p>Note: this function does not compute the perimeter on the borders of the domain.</p><pre><code class="language-julia hljs">using LevelSetMethods
R = 0.5
S0 = 2Ï€ * R
grid = CartesianGrid((-1, -1), (1, 1), (200, 200))
Ï• = LevelSetMethods.circle(grid; center = (0, 0), radius = R)
LevelSetMethods.perimeter(Ï•), S0

# output

(3.1426415491430366, 3.141592653589793)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L41-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.reinitialize!-Tuple{Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.reinitialize!-Tuple{Any, Any}"><code>LevelSetMethods.reinitialize!</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reinitialize!(Ï•::LevelSet, reinitializer = Reinitializer())</code></pre><p>Reinitializes the level set <code>Ï•</code> to a signed distance, modifying it in place.</p><p>The method works by first sampling the zero-level set of the interface, and then for each grid point, finding the closest point on the interface using a Newton-based method. The distance to the closest point is then used as the new value of the level set at that grid point, with the sign determined by the original level set value. See [<a href="../#saye2014high">4</a>] for more details.</p><p><strong>Arguments</strong></p><ul><li><code>Ï•</code>: The level set to reinitialize.</li><li><code>reinitializer</code>: Configuration for the reinitialization. Defaults to <code>Reinitializer()</code>. See <a href="#LevelSetMethods.Reinitializer"><code>Reinitializer</code></a> for details.</li></ul><div class="admonition is-info" id="Note-41525c04aa457363"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-41525c04aa457363" title="Permalink"></a></header><div class="admonition-body"><p>This functionality is provided by the <code>ReinitializationExt</code> module, which requires loading <code>Interpolations.jl</code> and <code>NearestNeighbors.jl</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/LevelSetMethods.jl#L59-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.set_makie_theme!"><a class="docstring-binding" href="#LevelSetMethods.set_makie_theme!"><code>LevelSetMethods.set_makie_theme!</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_makie_theme!()</code></pre><p>Set the <code>Makie</code> theme to <a href="#LevelSetMethods.makie_theme"><code>LevelSetMethods.makie_theme()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/LevelSetMethods.jl#L49-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.update_term!-Tuple{LevelSetMethods.LevelSetTerm, Any, Any}"><a class="docstring-binding" href="#LevelSetMethods.update_term!-Tuple{LevelSetMethods.LevelSetTerm, Any, Any}"><code>LevelSetMethods.update_term!</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_term!(term::LevelSetTerm, Ï•, t)</code></pre><p>Called before computing the term at each stage of the time evolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelsetequation.jl#L503-L507">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.volume-Tuple{LevelSet}"><a class="docstring-binding" href="#LevelSetMethods.volume-Tuple{LevelSet}"><code>LevelSetMethods.volume</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">volume(Ï•::LevelSet)</code></pre><p>Compute the volume of the level-set function.</p><pre><code class="language-julia hljs">using LevelSetMethods
R = 0.5
V0 = Ï€ * R^2
grid = CartesianGrid((-1, -1), (1, 1), (200, 200))
Ï• = LevelSetMethods.circle(grid; center = (0, 0), radius = R)
LevelSetMethods.volume(Ï•), V0

# output

(0.7854362890190668, 0.7853981633974483)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/src/levelset.jl#L15-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.export_surface_mesh-Tuple{LevelSet, String}"><a class="docstring-binding" href="#LevelSetMethods.export_surface_mesh-Tuple{LevelSet, String}"><code>LevelSetMethods.export_surface_mesh</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">export_surface_mesh(Ï•::LevelSet, output::String;
    hgrad = nothing, hmin = nothing, hmax = nothing, hausd = nothing)</code></pre><p>Compute a mesh of the <a href="#LevelSetMethods.LevelSet"><code>LevelSet</code></a> <code>Ï•</code> zero contour using MMGs_O3.</p><p><code>hgrad</code> control the growth ratio between two adjacent edges</p><p><code>hmin</code> and <code>hmax</code> control the edge sizes to be (respectively) greater than the <code>hmin</code> parameter and lower than the <code>hmax</code> one</p><p><code>hausd</code> control the maximal distance between the piecewise linear representation of the boundary and the reconstructed ideal boundary</p><div class="admonition is-info" id="Note-9b043e48124b5f26"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9b043e48124b5f26" title="Permalink"></a></header><div class="admonition-body"><p>Only works for 3 dimensional level-set.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/ext/MMGSurfaceExt.jl#L21-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.export_surface_mesh-Tuple{LevelSetEquation, Vararg{Any}}"><a class="docstring-binding" href="#LevelSetMethods.export_surface_mesh-Tuple{LevelSetEquation, Vararg{Any}}"><code>LevelSetMethods.export_surface_mesh</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">export_surface_mesh(eq::LevelSetEquation, args...; kwargs...)</code></pre><p>Call <a href="#LevelSetMethods.export_surface_mesh-Tuple{LevelSet, String}"><code>export_surface_mesh</code></a> on <code>current_state(eq)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/ext/MMGSurfaceExt.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.export_volume_mesh-Tuple{LevelSet, String}"><a class="docstring-binding" href="#LevelSetMethods.export_volume_mesh-Tuple{LevelSet, String}"><code>LevelSetMethods.export_volume_mesh</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">export_volume_mesh(Ï•::LevelSet, output::String;
    hgrad = nothing, hmin = nothing, hmax = nothing, hausd = nothing)</code></pre><p>Compute a mesh of the domains associated with <a href="#LevelSetMethods.LevelSet"><code>LevelSet</code></a> <code>eq</code> using either MMG2d<em>O3 or MMG3d</em>O3.</p><p><code>hgrad</code> control the growth ratio between two adjacent edges.</p><p><code>hmin</code> and <code>hmax</code> control the edge sizes to be (respectively) greater than the <code>hmin</code> parameter and lower than the <code>hmax</code> one.</p><p><code>hausd</code> control the maximal distance between the piecewise linear representation of the boundary and the reconstructed ideal boundary.</p><p>For more information, see the official <a href="http://www.mmgtools.org">MMG documentation</a>.</p><div class="admonition is-info" id="Note-c7904bbcaa105cb0"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c7904bbcaa105cb0" title="Permalink"></a></header><div class="admonition-body"><p>Only works for 2 and 3 dimensional level-set.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/ext/MMGVolumeExt.jl#L20-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LevelSetMethods.export_volume_mesh-Tuple{LevelSetEquation, Vararg{Any}}"><a class="docstring-binding" href="#LevelSetMethods.export_volume_mesh-Tuple{LevelSetEquation, Vararg{Any}}"><code>LevelSetMethods.export_volume_mesh</code></a> â€” <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">export_volume_mesh(eq::LevelSetEquation, output; kwargs...)</code></pre><p>Call <a href="#LevelSetMethods.export_volume_mesh-Tuple{LevelSet, String}"><code>export_volume_mesh</code></a> on <code>current_state(eq)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/f1a92b9d27c05f00aa0f446991b7b3f5d197d0c3/ext/MMGVolumeExt.jl#L11-L15">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example-shape-optim/">Â« Shape optimization: a primer</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Tuesday 24 February 2026 19:53">Tuesday 24 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
