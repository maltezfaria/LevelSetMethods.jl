var documenterSearchIndex = {"docs":
[{"location":"extension-reinitialization/#Reinitialization","page":"Reinitialization","title":"Reinitialization","text":"The ReinitializationExt extension provides a reinitialize! method to transform a level set function into a signed distance function by computing the closest point on the interface using Newton's method.","category":"section"},{"location":"extension-reinitialization/#Usage","page":"Reinitialization","title":"Usage","text":"After loading the required dependencies for this extension (Interpolations and NearestNeighbors), simply call reinitialize! on a LevelSet or a LevelSetEquation to reinitialize the level set function in-place:\n\nusing LevelSetMethods\nusing GLMakie\nusing NearestNeighbors\nusing Interpolations\n\ngrid = CartesianGrid((-1, -1), (1, 1), (100, 100))\n# An ellipse\nsdf = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid)\nœï = LevelSet(x -> x[1]^2 + x[2]^2 - 0.5^2, grid)\nLevelSetMethods.set_makie_theme!()\nfig = Figure(; size = (800, 300))\nax1 = Axis(fig[1, 1]; title=\"Signed Distance\")\nax2 = Axis(fig[1, 2]; title=\"Before Reinitialization\", ylabel = \"\", yticklabelsvisible = false)\nax3 = Axis(fig[1, 3]; title=\"After Reinitialization\", ylabel = \"\", yticklabelsvisible = false)\n\ncontour!(ax1, sdf; levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\ncontour!(ax2, œï; levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\n\n# Reinitialize using Newton's method\nreinitialize!(œï)\ncontour!(ax3, œï; levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\nfig\n\nYou can easily check that the reinitialized level set function is indeed a signed distance:\n\nmax_er = maximum(eachindex(grid)) do i\n  abs(œï[i] - sdf[i])\nend\n@test max_er < 1e-10 # hide\nprintln(\"Maximum error after reinitialization: $max_er\")","category":"section"},{"location":"extension-makie/#extension-makie","page":"Makie extension","title":"Makie extension","text":"Makie can be used to visualize level set functions in both 2 and 3 dimensions. After loading one of the Makie backends (we recommend GLMakie for 3D), you can simply call plot on the level set function to visualize it. For example:\n\nusing LevelSetMethods, GLMakie\ngrid = CartesianGrid((-2, -2), (2, 2), (100, 100))\nœï = LevelSetMethods.star(grid)\nplot(œï)\n\nBy default, only the zero level set is plotted as a contour line. For more control, simply call the contour (or contourf) function from Makie directly. For example:\n\ncontour(œï; levels = [-0.5, 0, 0.5], labels = true)\n\nAlthough you can manually customize the Axis attributes for the plot, LevelSetMethods provides a Theme with some reasonable defaults for plotting level set functions:\n\ntheme = LevelSetMethods.makie_theme()\nwith_theme(theme) do\n  plot(œï)\nend\n\nIn 3D, the plot function will plot the zero level set as an isosurface. For example:\n\nusing LevelSetMethods, GLMakie, LinearAlgebra\ngrid = CartesianGrid((-1.5, -1.5, -1.5), (1.5, 1.5, 1.5), (50, 50, 50))\nP1, P2 = (-1, 0, 0), (1, 0, 0)\nb = 1.05\nœï = LevelSet(grid) do x\n  norm(x .- P1)*norm(x .- P2) - b^2\nend\ntheme = LevelSetMethods.makie_theme()\nwith_theme(theme) do\n  plot(œï)\nend\n\nOnce again, you can manually customize the options by calling the volume function from Makie directly:\n\nwith_theme(theme) do\n  volume(œï; algorithm = :iso, isovalue = 0.5)\nend\n\ntip: Plotting a `LevelSetEquation`\nCalling plot on a LevelSetEquation defaults to plotting the LevelSet given by its current_state; exactly the same as calling plot(current_state(equation)).","category":"section"},{"location":"time-integrators/#time-integrators","page":"Time integration","title":"Time integration","text":"The following options are available for time integration:\n\nusing LevelSetMethods\nusing InteractiveUtils # hide\nsubtypes(LevelSetMethods.TimeIntegrator)\n\nForwardEuler, RK2, and RK3 are explicit schemes, and therefore a sufficiently small time step, dependant on the LevelSetTerm being used, is required to ensure stability. We recommend using the second order RK2 scheme for most applications.\n\nThe package also provides SemiImplicitI2OE, a semi-implicit scheme (Mikula et al.) for advection equations.","category":"section"},{"location":"boundary-conditions/#boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"The following boundary conditions are available:\n\nusing LevelSetMethods\nusing InteractiveUtils # hide\nsubtypes(LevelSetMethods.BoundaryCondition)\n\nWhen constructing a level-set equation, you can pass up to 2^d boundary conditions, where d is the dimension of the space. The following convention is followed:\n\nif you pass a single boundary condition, it is applied to all 2^d boundaries\nif you pass a vector bcs of d boundary conditions, the i-th element is applied to the i-th direction. Two options are then possible:\nbcs[i] is a single boundary condition, in which case it is applied to both boundaries in the i-th direction\nbcs[i] is a tuple of two boundary conditions, in which case the first element is applied to the lower/left boundary and the second element to the upper/right boundary\n\nHere is how it looks in practice:\n\nusing LevelSetMethods, GLMakie\ngrid = CartesianGrid((-1,-1), (1,1), (100, 100))\nœï‚ÇÄ    = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid)\nbc   = PeriodicBC()\neq   = LevelSetEquation(; levelset = deepcopy(œï‚ÇÄ), bc, terms = AdvectionTerm((x,t) -> (1,0)))\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig\n\nChanging PeriodicBC() to NeumannBC() gives allows for the level-set to \"leak\" out of the domain:\n\neq   = LevelSetEquation(; levelset = deepcopy(œï‚ÇÄ), bc = NeumannBC(), terms = AdvectionTerm((x,t) -> (1,0)))\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig\n\nTo combine both boundary conditions you can use\n\nbc = (NeumannBC(), PeriodicBC()) # Neumann in x, periodic in y\neq   = LevelSetEquation(; levelset = deepcopy(œï‚ÇÄ), bc, terms = AdvectionTerm((x,t) -> (1,1)))\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig\n\nFor more details on each boundary condition, see the docstring for the corresponding type.","category":"section"},{"location":"terms/#terms","page":"Level-set terms","title":"Level-set terms","text":"A level-set equation is given by\n\n  phi_t + sum_n textttterm_n = 0\n\nwhere each textttterm_n is a LevelSetTerm object. The following terms are available:\n\nusing LevelSetMethods\nusing InteractiveUtils # hide\nsubtypes(LevelSetMethods.LevelSetTerm)\n\nHere we investigate the meaning of each term, and how they can be used to model different phenomena.","category":"section"},{"location":"terms/#advection","page":"Level-set terms","title":"Advection","text":"The simplest term is the advection term, which is given by\n\n  mathbfu cdot nabla phi\n\nwhere mathbfu is a velocity field. This term models the transport of the level-set by an external velocity field (see [1, Chapter 3]). You can construct an advection term using the AdvectionTerm structure:\n\nusing LevelSetMethods, StaticArrays\ngrid = CartesianGrid((-1,-1), (1,1), (100, 100))\nùêÆ = MeshField(x -> SVector(1,0), grid)\nAdvectionTerm(ùêÆ)\n\nIn the example above we passed a MeshField object to the AdvectionTerm constructor, meaning that the velocity field is simply a vector of values at each grid point. This is useful if your velocity field is time-independent, or if you only know it at grid points. Lets construct a level-set equation with an advection term:\n\nœï‚ÇÄ = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid)\neq = LevelSetEquation(; terms = (AdvectionTerm(ùêÆ),), levelset = œï‚ÇÄ, bc = PeriodicBC())\n\nTo see how the advection term affects the level-set, we can solve the equation for a few time steps:\n\nusing GLMakie\nLevelSetMethods.set_makie_theme!()\nfig = Figure(; size = (1200, 300))\n# create a 2 x 2 figure\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    I = CartesianIndices((2,2))[n]\n    integrate!(eq, t)\n    # ax = Axis(fig[I[1],I[2]])\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig\n\nIn the example above we see that the level-set is advected to the right. If we wanted to have instead a time-dependent velocity field, we could pass a function to the AdvectionTerm, and the velocity field would be computed at each time step. For example:\n\nœï‚ÇÄ = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid)\neq = LevelSetEquation(; terms = (AdvectionTerm((x,t) -> SVector(x[1]^2, 0)),), levelset = œï‚ÇÄ, bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\n# create a 2 x 2 figure\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    I = CartesianIndices((2,2))[n]\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig\n\nNote that the velocity function must accept two arguments: the spatial coordinates x, which is an abstract vector of length d, and the time t. Furthermore, it should return a vector of length d.\n\nBesides the velocity field, the AdvectionTerm constructor also accepts a scheme as a second argument to specify the discretization scheme. The available options are:\n\nUpwind(): first-order upwind scheme\nWENO5(): fifth-order WENO scheme (default)\n\nThe WENO scheme is more expensive but much more accurate and is usually preferable to the upwind scheme, which introduces significant numerical diffusion. To see their differences, let us compare both schemes for a purely rotational velocity field:\n\nœï‚ÇÄ = LevelSetMethods.dumbbell(grid) # pre-defined level-set\nùêÆ  = MeshField(grid) do (x,y)\n    SVector(-y, x)\nend\neq_upwind = LevelSetEquation(; terms = AdvectionTerm(ùêÆ, Upwind()), levelset = deepcopy(œï‚ÇÄ), bc = PeriodicBC())\neq_weno   = LevelSetEquation(; terms = AdvectionTerm(ùêÆ), levelset  = deepcopy(œï‚ÇÄ), bc = PeriodicBC())\nfig = Figure(size = (1000, 400))\nax = Axis(fig[1,1], title = \"Initial\")\nplot!(ax, eq_upwind)\n# do half a revolution\ntf = œÄ\nax = Axis(fig[1,2], title = \"Upwind (final time)\")\nintegrate!(eq_upwind, tf)\nplot!(ax, eq_upwind)\nax = Axis(fig[1,3], title = \"WENO5 (final time)\")\nintegrate!(eq_weno, tf)\nplot!(ax, eq_weno)\nfig","category":"section"},{"location":"terms/#normal-motion","page":"Level-set terms","title":"Normal motion","text":"The normal motion term is given by\n\n  v nabla phi\n\nwhere v is a scalar field. This term models the motion of the level-set in the normal direction (see [1, Chapter 6]). Here is an example of how to use it:\n\nusing LevelSetMethods\nusing GLMakie\ngrid = CartesianGrid((-2,-2), (2,2), (100, 100))\nœï = LevelSetMethods.star(grid)\neq = LevelSetEquation(; terms = (NormalMotionTerm((x,t) -> 0.5),), levelset = œï, bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig\n\nAs with AdvectionTerm, you can provide an update callback to mutate a mesh-based speed field before each stage of time integration:\n\nvfield = MeshField(x -> 0.0, grid)\nterm = NormalMotionTerm(vfield, (v, œï, t) -> (values(v) .= 0.25 + 0.1 * t))\nterm\n\nIn Stefan problems, the speed v may only be known near the interface œï = 0. You can extend that interface speed to a band around the interface using the extend_along_normals!, and then pass it to NormalMotionTerm:\n\nœïext = LevelSetMethods.star(grid)\nv = zeros(Float64, size(grid)...)\nŒî = minimum(LevelSetMethods.meshsize(grid))\nfrozen = abs.(values(œïext)) .<= 1.5Œî\nfor I in CartesianIndices(v)\n    frozen[I] || continue\n    x = grid[I]\n    v[I] = 0.2 + 0.1 * cos(2œÄ * atan(x[2], x[1]))\nend\nextend_along_normals!(v, œïext; frozen, nb_iters = 80)\nterm = NormalMotionTerm(MeshField(v, grid, nothing))\nterm","category":"section"},{"location":"terms/#curvature","page":"Level-set terms","title":"Curvature motion","text":"This terms models the motion of the level-set in the normal direction with a velocity that is proportional to the mean curvature:\n\n  b kappa nabla phi\n\nwhere kappa = nabla cdot (nabla phi  nabla phi) is the mean curvature. Note that the coefficient b should be negative; a positive value of b would yield an ill-posed evolution problem (akin to a negative diffusion coefficient).\n\nHere is the classic example of motion by mean curavature for a spiral-like level-set:\n\nusing LevelSetMethods, GLMakie\ngrid = CartesianGrid((-1,-1), (1,1), (100, 100))\n# create a spiral level-set\nd = 1\nr0 = 0.5\nŒ∏0 = -œÄ / 3\nŒ± = œÄ / 100.0\nR = [cos(Œ±) -sin(Œ±); sin(Œ±) cos(Œ±)]\nM = R * [1/0.06^2 0; 0 1/(4œÄ^2)] * R'\nœï = LevelSet(grid) do (x, y)\n    r = sqrt(x^2 + y^2)\n    Œ∏ = atan(y, x)\n    result = 1e30\n    for i in 0:4\n        Œ∏1 = Œ∏ + (2i - 4) * œÄ\n        v = [r - r0; Œ∏1 - Œ∏0]\n        result = min(result, sqrt(v' * M * v) - d)\n    end\n    return result\nend\neq = LevelSetEquation(; terms = (CurvatureTerm((x,t) -> -0.1),), levelset = œï, bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.1, 0.2, 0.3])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig","category":"section"},{"location":"terms/#reinitialization","page":"Level-set terms","title":"Reinitialization term","text":"The reinitialization term is given by\n\n  phi_t + textsign(phi) left( nabla phi - 1 right) = 0\n\nThis term is used to ensure that the level-set function remains close to a signed distance function, which is sometimes important for numerical stability. The idea of the evolution equation above is to penalize the deviation of the level-set from a signed distance function, where nabla phi = 1, without changing the zero level-set. In practice a smeared sign function is used; see [1, Chapter 7] for more details.\n\nHere is an example of how to use the reinitialization term to obtain a signed distance function from a level-set. Let us first create a level-set that is not a signed distance, and its signed distance function:\n\nusing LevelSetMethods, GLMakie\ngrid = CartesianGrid((-1,-1), (1,1), (100, 100))\nœï = LevelSet(x -> x[1]^2 + x[2]^2 - 0.5^2, grid) # circle level-set, but not a signed distance function\nsdf = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid) # signed distance function\nLevelSetMethods.set_makie_theme!()\nfig = Figure(; size = (800, 400))\nax = Axis(fig[1,1], title = \"Signed distance function\")\ncontour!(ax, sdf; levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\nax = Axis(fig[1,2], title = \"œï at t = 0\")\ncontour!(ax, œï, levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\nfig\n\nWe will now evolve the level-set using the reinitialization term:\n\neq = LevelSetEquation(; terms = (ReinitializationTerm(),), levelset = deepcopy(œï), bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.25, 0.5, 0.75])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    contour!(ax, LevelSetMethods.current_state(eq); levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\nend\nfig\n\nObserve that as the reinitialization equation evolves, œï approaches the signed distance function sdf depicted in the first figure.\n\nAlternatively, you can use a modified reinitialization term that applies the sign function to the initial level-set function only:\n\n  phi_t + textsign(phi_0) left( nabla phi - 1 right) = 0\n\nTo enable this behavior, simply pass a LevelSet object to the ReinitializationTerm:\n\neq = LevelSetEquation(; terms = (ReinitializationTerm(œï),), levelset = deepcopy(œï), bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.25, 0.5, 0.75])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    contour!(ax, LevelSetMethods.current_state(eq); levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\nend\nfig\n\nThe outcome closely matches that of the previous approach.","category":"section"},{"location":"extension-mmg/#extension-mmg","page":"MMG extension","title":"MMG extension","text":"This extension provides functions to generate meshes of level-set functions using MMG. It defines two methods: export_volume_mesh and export_surface_mesh. For both of them, it is possible to control the size of the generated mesh using the following optional parameters:\n\nhgrad control the growth ratio between two adjacent edges.\nhmin and hmax control the edge sizes to be (respectively) greater than the hmin parameter and lower than the hmax one.\nhausd control the maximal distance between the piecewise linear representation of the boundary and the reconstructed ideal boundary.","category":"section"},{"location":"extension-mmg/#Generation-of-2D-and-3D-mesh-from-a-level-set","page":"MMG extension","title":"Generation of 2D and 3D mesh from a level-set","text":"For 2 and 3-dimensional Cartesian level set, one can use the export_volume_mesh function to generate meshes. This method relies on the mmg2d_O3 and mmg3d_O3 utilities. Example in 2D:\n\nusing LevelSetMethods, MMG_jll\ngrid = CartesianGrid((-2, -2), (2, 2), (50, 50))\nœï = LevelSetMethods.star(grid)\nvolume_mesh2d = LevelSetMethods.export_volume_mesh(œï, joinpath(@__DIR__, \"volume2D.mesh\"))\n\nYou can then use e.g. Gmsh to visualize the mesh:\n\nusing GLMakie # hide\nGLMakie.closeall() # hide\nusing Gmsh\ntry\n  gmsh.initialize()\n  gmsh.option.setNumber(\"General.Verbosity\", 0)\n  gmsh.open(volume_mesh2d)\n  gmsh.fltk.initialize()\n  gmsh.write(joinpath(@__DIR__, \"volume2d.png\"))\n  gmsh.fltk.finalize()\nfinally\n  gmsh.finalize()\nend\n\n\n(Image: Volume2D)\n\nAnd similarly in 3D:\n\nusing LevelSetMethods, MMG_jll\ngrid = CartesianGrid((-1, -1, -1), (+1, +1, +1), (20, 20, 20))\nœï = LevelSetMethods.sphere(grid; radius = 0.5)\nvolume_mesh3d = LevelSetMethods.export_volume_mesh(œï, joinpath(@__DIR__, \"volume3d.mesh\"))\n\n(Image: Volume3D)","category":"section"},{"location":"extension-mmg/#Generation-of-3D-surface-mesh-with-MarchingCubes.jl","page":"MMG extension","title":"Generation of 3D surface mesh with MarchingCubes.jl","text":"Using the mmgs_O3 utility, the MarchingCubes.jl library and the export_surface_mesh function it is possible to obtain a mesh of the levelset contour.\n\nusing LevelSetMethods, MMG_jll, MarchingCubes\ngrid = CartesianGrid((-2, -1, -1), (+2, +1, +1), (40, 20, 20))\nœï‚ÇÅ = LevelSetMethods.sphere(grid; radius = 0.5, center = (-1, 0, 0))\nœï‚ÇÇ = LevelSetMethods.sphere(grid; radius = 0.5, center = (+1, 0, 0))\nœï‚ÇÉ = LevelSetMethods.rectangle(grid; center = (0, 0, 0), width = (2, 0.25, 0.25))\nœï  = œï‚ÇÅ ‚à™ œï‚ÇÇ ‚à™ œï‚ÇÉ\nsurf_mesh3d = LevelSetMethods.export_surface_mesh(œï, joinpath(@__DIR__,\"surface3D.mesh\"); hausd = 1.2, hmax = 1.0)\n\nAgain, to visualize it we can use Gmsh:\n\nusing GLMakie # hide\nGLMakie.closeall() # hide\nusing Gmsh\ntry\n  gmsh.initialize()\n  gmsh.option.setNumber(\"General.Verbosity\", 0)\n  gmsh.open(surf_mesh3d)\n  gmsh.fltk.initialize()\n  gmsh.write(joinpath(@__DIR__, \"surface3d.png\"))\n  gmsh.fltk.finalize()\nfinally\n  gmsh.finalize()\nend\n\n\n(Image: Surface3D)","category":"section"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#LevelSetMethods.AbstractMesh","page":"Reference","title":"LevelSetMethods.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract mesh structure in dimension N with primite data of type T.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.AdvectionTerm","page":"Reference","title":"LevelSetMethods.AdvectionTerm","text":"AdvectionTerm(ùêÆ[, scheme = WENO5(), update_func = nothing])\n\nAdvection term representing  ùêÆ ‚ãÖ ‚àáœï. Available schemes are Upwind and WENO5.\n\nIf passed, update_func will be called as update_func(ùêÆ, œï, t) before computing the term at each stage of the time evolution. This can be used to update the velocity field ùêÆ depending not only on t, but also on the current level set œï.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.BoundaryCondition","page":"Reference","title":"LevelSetMethods.BoundaryCondition","text":"abstract type BoundaryCondition\n\nTypes used to specify boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.CartesianGrid-Tuple{Any, Any, Any}","page":"Reference","title":"LevelSetMethods.CartesianGrid","text":"CartesianGrid(lc, hc, n)\n\nCreate a uniform cartesian grid with lower corner lc, upper corner hc and and n nodes in each direction.\n\nExamples\n\nusing LevelSetMethods\na = (0, 0)\nb = (1, 1)\nn = (10, 4)\ngrid = CartesianGrid(a, b, n)\n\n# output\n\nCartesianGrid{2, Int64}([0, 0], [1, 1], (10, 4))\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.CartesianMeshField","page":"Reference","title":"LevelSetMethods.CartesianMeshField","text":"const CartesianMeshField{V,M<:CartesianGrid} = MeshField{V,M}\n\nMeshField over a CartesianGrid.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.CurvatureTerm","page":"Reference","title":"LevelSetMethods.CurvatureTerm","text":"struct CurvatureTerm{V,M} <: LevelSetTerm\n\nLevel-set curvature term representing bŒ∫|‚àáœï|, where Œ∫ = ‚àá ‚ãÖ (‚àáœï/|‚àáœï|) is the curvature.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.DirichletBC","page":"Reference","title":"LevelSetMethods.DirichletBC","text":"struct DirichletBC{T} <: BoundaryCondition\n\nA Dirichlet boundary condition taking values of f(x) at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.LevelSet","page":"Reference","title":"LevelSetMethods.LevelSet","text":"LevelSet\n\nAlias for MeshField with vals as an AbstractArray of Reals.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.LevelSetEquation-Tuple{}","page":"Reference","title":"LevelSetMethods.LevelSetEquation","text":"LevelSetEquation(; terms, levelset, boundary_conditions, t = 0, integrator = RK2(),\nreinit = nothing)\n\nCreate a of a level-set equation of the form œï‚Çú + sum(terms) = 0, where each t ‚àà terms is a LevelSetTerm and levelset is the initial LevelSet.\n\nCalling integrate!(ls, tf) will evolve the level-set equation up to time tf, modifying the current_state(eq) and current_time(eq) of the object eq in the process (and therefore the original levelset).\n\nBoundary conditions can be specified in two ways. If a single BoundaryCondition is provided, it will be applied uniformly to all boundaries of the domain. To apply different boundary conditions to each boundary, pass a tuple of the form (bc_x, bc_y, ...) with as many elements as dimensions in the domain. If bc_x is a BoundaryCondition, it will be applied to both boundaries in the x direction. If bc_x is a tuple of two BoundaryConditions, the first will be applied to the left boundary and the second to the right boundary. The same logic applies to the other dimensions.\n\nThe optional parameter t specifies the initial time of the simulation, and integrator is the TimeIntegrator used to evolve the level-set equation.\n\nReinitialization of the level-set function is controlled by the reinit parameter, a Reinitializer object that specifies both the reinitialization algorithm parameters and the frequency (in time steps). By default, no automatic reinitialization is performed. Using this feature requires the ReinitializationExt to be loaded.\n\nusing LevelSetMethods, StaticArrays\ngrid = CartesianGrid((-1, -1), (1, 1), (50, 50))    # define the grid\nœï = LevelSet(x -> x[1]^2 + x[2]^2 - 0.5^2, grid)    # initial shape\nùêÆ = MeshField(x -> SVector(1, 0), grid)             # advection velocity\nterms = (AdvectionTerm(ùêÆ),)            # advection and curvature terms\nbc = PeriodicBC()                                   # periodic boundary conditions\neq = LevelSetEquation(; terms, levelset = œï, bc)    # level-set equation\n\n# output\n\nLevel-set equation given by\n\n \t œï‚Çú + ùêÆ ‚ãÖ ‚àá œï = 0\n\nCurrent time 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.LevelSetTerm","page":"Reference","title":"LevelSetMethods.LevelSetTerm","text":"abstract type LevelSetTerm\n\nA typical term in a level-set evolution equation.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.MeshField","page":"Reference","title":"LevelSetMethods.MeshField","text":"struct MeshField{V,M,B}\n\nA field described by its discrete values on a mesh.\n\nBase.getindex of an MeshField is overloaded to handle indices that lie outside the CartesianIndices of its MeshField by using bcs.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.MeshField-Tuple{Function, Any}","page":"Reference","title":"LevelSetMethods.MeshField","text":"MeshField(f::Function, m)\n\nCreate a MeshField by evaluating a function f on a mesh m.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.NeumannBC","page":"Reference","title":"LevelSetMethods.NeumannBC","text":"struct NeumannBC <: BoundaryCondition\n\nHomogenous Neumann boundary condition, i.e. ‚àÇx œï = 0.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.NeumannGradientBC","page":"Reference","title":"LevelSetMethods.NeumannGradientBC","text":"struct NeumannGradientBC <: BoundaryCondition\n\nHomogenous Neumann gradient boundary condition, i.e. ‚àÇxx œï = 0.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.NormalMotionTerm","page":"Reference","title":"LevelSetMethods.NormalMotionTerm","text":"struct NormalMotionTerm{V,F} <: LevelSetTerm\n\nLevel-set advection term representing  v |‚àáœï|. This LevelSetTerm should be used for internally generated velocity fields; for externally generated velocities you may use AdvectionTerm instead.\n\nIf passed, update_func will be called as update_func(v, œï, t) before computing the term at each stage of the time evolution.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.PeriodicBC","page":"Reference","title":"LevelSetMethods.PeriodicBC","text":"struct PeriodicBC <: BoundaryCondition\n\nSingleton type representing periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.RK2","page":"Reference","title":"LevelSetMethods.RK2","text":"struct RK2\n\nSecond order total variation dimishing Runge-Kutta scheme, also known as Heun's predictor-corrector method.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.RK3","page":"Reference","title":"LevelSetMethods.RK3","text":"struct RK3\n\nThird order total variation dimishing Runge-Kutta scheme.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.ReinitializationTerm","page":"Reference","title":"LevelSetMethods.ReinitializationTerm","text":"struct ReinitializationTerm <: LevelSetTerm\n\nLevel-set term representing  sign(œï) (|‚àáœï| - 1). This LevelSetTerm should be used for reinitializing the level set into a signed distance function: for a sufficiently large number of time steps this term allows one to solve the Eikonal equation |‚àáœï| = 1.\n\nThere are two ways of constructing a ReinitializationTerm:\n\nusing ReinitializationTerm(œï‚ÇÄ::LevelSet) precomputes the sign term on the initial level set œï‚ÇÄ, as in equation 7.5 of Osher and Fedkiw;\nusing ReinitializationTerm() constructs a term that computes the sign term on-the-fly at each time step, as in equation 7.6 of Osher and Fedkiw.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.Reinitializer","page":"Reference","title":"LevelSetMethods.Reinitializer","text":"Reinitializer(; upsample=8, maxiters=20, xtol=1e-8, ftol=1e-8, reinit_freq=1)\n\nConfiguration for Newton-based reinitialization to a signed distance function. The reinit_freq parameter specifies how often reinitialization is performed (in time steps).\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.SemiImplicitI2OE","page":"Reference","title":"LevelSetMethods.SemiImplicitI2OE","text":"struct SemiImplicitI2OE\n\nSemi-implicit finite-volume scheme of the I2OE family (Mikula et al.) for advection problems.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.TimeIntegrator","page":"Reference","title":"LevelSetMethods.TimeIntegrator","text":"abstract type TimeIntegrator end\n\nAbstract type for time integrators. See subtypes(TimeIntegrator) for a list of available time integrators.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.D2-Tuple{Any, Any, Any}","page":"Reference","title":"LevelSetMethods.D2","text":"D2(œï::CartesianMeshField,I,dims)\n\nFinite difference scheme for second order derivative at grid point I along the dimensions dims.\n\nIf dims[1] == dims[2], it is more efficient to call D2‚Å∞(œï,I,dims[1]).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D2‚Å∞-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D2‚Å∞","text":"D2‚Å∞(œï::CartesianMeshField,I,dim)\n\nCentered finite difference scheme for second order derivative at grid point I along dimension dim. E.g. if dim=1, this approximates ‚àÇ‚Çì‚Çì.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D2‚Å∫‚Å∫-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D2‚Å∫‚Å∫","text":"D2‚Å∫‚Å∫(œï::CartesianMeshField,I,dim)\n\nUpward finite difference scheme for second order derivative at grid point I along dimension dim. E.g. if dim=1, this approximates ‚àÇ‚Çì‚Çì.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D2‚Åª‚Åª-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D2‚Åª‚Åª","text":"D2‚Åª‚Å∫(œï::CartesianMeshField,I,dim)\n\nBackward finite difference scheme for second order derivative at grid point I along dimension dim. E.g. if dim=1, this approximates ‚àÇ‚Çì‚Çì.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D‚Å∞-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D‚Å∞","text":"D‚Å∞(œï::CartesianMeshField,I,dim)\n\nCentered finite difference scheme for first order derivative at grid point I along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D‚Å∫-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D‚Å∫","text":"D‚Å∫(œï::CartesianMeshField,I,dim)\n\nForward finite difference scheme for first order derivative at grid point I along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D‚Åª-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D‚Åª","text":"D‚Åª(œï::CartesianMeshField,I,dim)\n\nBackward finite difference scheme for first order derivative at grid point I along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.curvature-Tuple{LevelSet, Any}","page":"Reference","title":"LevelSetMethods.curvature","text":"curvature(œï::LevelSet, I)\n\nCompute the mean curvature of œï at I using Œ∫ = ‚àá ‚ãÖ (‚àáœï / |‚àáœï|). We use the formula Œ∫ = (Œîœï |‚àáœï|^2 - ‚àáœï^T Hœï ‚àáœï) / |‚àáœï|^3 with first order finite differences. https://en.wikipedia.org/wiki/Meancurvature#Implicitformofmean_curvature\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.curvature-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.curvature","text":"curvature(œï::LevelSet)\n\nCompute the mean curvature of œï at I using Œ∫ = ‚àá ‚ãÖ (‚àáœï / |‚àáœï|). See curvature(œï::LevelSet, I) for more details.\n\nusing LevelSetMethods\nN = 50\ngrid = CartesianGrid((-1, -1), (1, 1), (N, N))\nœï = LevelSetMethods.star(grid)\nusing GLMakie\ncoeff = exp.(-40.0 * values(œï) .^ 2)\nŒ∫ = curvature(œï) .* coeff\nxs = LevelSetMethods.grid1d(grid, 1)\nys = LevelSetMethods.grid1d(grid, 2)\nfig, ax, hm = heatmap(xs, ys, Œ∫)\nColorbar(fig[:, end+1], hm)\ncontour!(xs, ys, values(œï); levels = [0.0])\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.extend_along_normals!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, LevelSet}} where {T<:Real, N}","page":"Reference","title":"LevelSetMethods.extend_along_normals!","text":"extend_along_normals!(F, œï::LevelSet;\n                      nb_iters = 50,\n                      cfl = 0.45,\n                      frozen = nothing,\n                      interface_band = 1.5,\n                      min_norm = 1e-14)\n\nExtend a scalar speed field F away from the interface of œï by solving in pseudo-time ‚àÇœÑF + sign(œï) n‚ãÖ‚àáF = 0, with n = ‚àáœï / |‚àáœï|.\n\nThe equation is discretized with first-order upwind derivatives. The update preserves frozen nodes (Dirichlet constraint). If frozen is not provided, a mask is built from the interface band abs(œï) <= interface_band * Œî, where Œî = minimum(meshsize(œï)).\n\nF can be an AbstractArray (same size as œï) or a MeshField on the same mesh.\n\nReference from [Peng et al. 1999]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.grad_norm-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.grad_norm","text":"grad_norm(œï::LevelSet[, I])\n\nCompute the norm of the gradient of œï at index I, i.e. |‚àáœï|, or for all grid points if I is not provided.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.gradient-Tuple{LevelSet, Any}","page":"Reference","title":"LevelSetMethods.gradient","text":"gradient(œï::LevelSet, I)\n\nReturn the gradient vector ‚àáœï of œï at I\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.hessian-Tuple{LevelSet, Any}","page":"Reference","title":"LevelSetMethods.hessian","text":"hessian(œï::LevelSet, I)\n\nReturn the Hessian matrix Hœï of œï at I\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.integrate!","page":"Reference","title":"LevelSetMethods.integrate!","text":"integrate!(ls::LevelSetEquation,tf,Œît=Inf)\n\nIntegrate the LevelSetEquation ls up to time tf, mutating the levelset and current_time of the object ls in the process.\n\nAn optional parameter Œît can be passed to specify a maximum time-step allowed for the integration. Note that the internal time-steps taken to evolve the level-set up to tf may be smaller than Œît due to stability reasons related to the terms and integrator employed.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LevelSetMethods.makie_theme","page":"Reference","title":"LevelSetMethods.makie_theme","text":"makie_theme()\n\nReturn a Makie theme for plots of level-set functions.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LevelSetMethods.normal-Tuple{LevelSet, Any}","page":"Reference","title":"LevelSetMethods.normal","text":"normal(œï::LevelSet, I)\n\nCompute the unit exterior normal vector of œï at I using n = ‚àáœï/|‚àáœï|\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.normal-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.normal","text":"normal(œï::LevelSet)\n\nCompute the unit exterior normal vector of œï using n = ‚àáœï/|‚àáœï|\n\nusing LevelSetMethods\nN = 50\ngrid = CartesianGrid((-1, -1), (1, 1), (N, N))\nœï = LevelSetMethods.star(grid)\nusing GLMakie\nn = normal(œï)\nxs = LevelSetMethods.grid1d(grid, 1)\nys = LevelSetMethods.grid1d(grid, 2)\ncoeff = exp.(-40.0 * values(œï) .^ 2)\nus = getindex.(n, 1) .* coeff\nvs = getindex.(n, 2) .* coeff\narrows(xs, ys, us, vs; arrowsize = 10 * vec(coeff), lengthscale = 2.0 / (N - 1))\ncontour!(xs, ys, values(œï); levels = [0.0])\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.perimeter-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.perimeter","text":"perimeter(œï::LevelSet)\n\nCompute the perimeter area of the level-set function.\n\nNote: this function does not compute the perimeter on the borders of the domain.\n\nusing LevelSetMethods\nR = 0.5\nS0 = 2œÄ * R\ngrid = CartesianGrid((-1, -1), (1, 1), (200, 200))\nœï = LevelSetMethods.circle(grid; center = (0, 0), radius = R)\nLevelSetMethods.perimeter(œï), S0\n\n# output\n\n(3.1426415491430366, 3.141592653589793)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.reinitialize!-Tuple{Any, Any}","page":"Reference","title":"LevelSetMethods.reinitialize!","text":"reinitialize!(œï::LevelSet, reinitializer = Reinitializer())\n\nReinitializes the level set œï to a signed distance, modifying it in place.\n\nThe method works by first sampling the zero-level set of the interface, and then for each grid point, finding the closest point on the interface using a Newton-based method. The distance to the closest point is then used as the new value of the level set at that grid point, with the sign determined by the original level set value. See [4] for more details.\n\nArguments\n\nœï: The level set to reinitialize.\nreinitializer: Configuration for the reinitialization. Defaults to Reinitializer(). See Reinitializer for details.\n\nnote: Note\nThis functionality is provided by the ReinitializationExt module, which requires loading Interpolations.jl and NearestNeighbors.jl.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.set_makie_theme!","page":"Reference","title":"LevelSetMethods.set_makie_theme!","text":"set_makie_theme!()\n\nSet the Makie theme to LevelSetMethods.makie_theme().\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LevelSetMethods.update_term!-Tuple{LevelSetMethods.LevelSetTerm, Any, Any}","page":"Reference","title":"LevelSetMethods.update_term!","text":"update_term!(term::LevelSetTerm, œï, t)\n\nCalled before computing the term at each stage of the time evolution.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.volume-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.volume","text":"volume(œï::LevelSet)\n\nCompute the volume of the level-set function.\n\nusing LevelSetMethods\nR = 0.5\nV0 = œÄ * R^2\ngrid = CartesianGrid((-1, -1), (1, 1), (200, 200))\nœï = LevelSetMethods.circle(grid; center = (0, 0), radius = R)\nLevelSetMethods.volume(œï), V0\n\n# output\n\n(0.7854362890190668, 0.7853981633974483)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.export_surface_mesh-Tuple{LevelSet, String}","page":"Reference","title":"LevelSetMethods.export_surface_mesh","text":"export_surface_mesh(œï::LevelSet, output::String;\n    hgrad = nothing, hmin = nothing, hmax = nothing, hausd = nothing)\n\nCompute a mesh of the LevelSet œï zero contour using MMGs_O3.\n\nhgrad control the growth ratio between two adjacent edges\n\nhmin and hmax control the edge sizes to be (respectively) greater than the hmin parameter and lower than the hmax one\n\nhausd control the maximal distance between the piecewise linear representation of the boundary and the reconstructed ideal boundary\n\nnote: Note\nOnly works for 3 dimensional level-set.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.export_surface_mesh-Tuple{LevelSetEquation, Vararg{Any}}","page":"Reference","title":"LevelSetMethods.export_surface_mesh","text":"export_surface_mesh(eq::LevelSetEquation, args...; kwargs...)\n\nCall export_surface_mesh on current_state(eq).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.export_volume_mesh-Tuple{LevelSet, String}","page":"Reference","title":"LevelSetMethods.export_volume_mesh","text":"export_volume_mesh(œï::LevelSet, output::String;\n    hgrad = nothing, hmin = nothing, hmax = nothing, hausd = nothing)\n\nCompute a mesh of the domains associated with LevelSet eq using either MMG2dO3 or MMG3dO3.\n\nhgrad control the growth ratio between two adjacent edges.\n\nhmin and hmax control the edge sizes to be (respectively) greater than the hmin parameter and lower than the hmax one.\n\nhausd control the maximal distance between the piecewise linear representation of the boundary and the reconstructed ideal boundary.\n\nFor more information, see the official MMG documentation.\n\nnote: Note\nOnly works for 2 and 3 dimensional level-set.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.export_volume_mesh-Tuple{LevelSetEquation, Vararg{Any}}","page":"Reference","title":"LevelSetMethods.export_volume_mesh","text":"export_volume_mesh(eq::LevelSetEquation, output; kwargs...)\n\nCall export_volume_mesh on current_state(eq).\n\n\n\n\n\n","category":"method"},{"location":"example-zalesak/#zalesak","page":"Zalesak disk","title":"Zalesak disk","text":"This example demonstrates the setup and simulation of a Zalesak disk, a standard benchmark in computational fluid dynamics, using the LevelSetMethods.jl.","category":"section"},{"location":"example-zalesak/#Setting-up-the-Grid-and-Disk","page":"Zalesak disk","title":"Setting up the Grid and Disk","text":"First, we create a Cartesian grid to represent the computational domain. We define a circular disk with a rectangular cut to form the Zalesak disk.\n\n# Define the computational grid\ngrid = CartesianGrid((-1.5, -1.5), (1.5, 1.5), (100, 100))\n# Define the center and radius of the circular disk\ncenter = (-0.75, 0)\nradius = 0.5\n# Define the height and width of the rectangular notch\nh = 1.0\nw = 0.2\n# Create the circular disk and rectangular notch\ndisk = LevelSetMethods.circle(grid; center, radius)\nrec = LevelSetMethods.rectangle(grid; center = center .- (0, radius), width = (w, h))\n# Use set difference to carve out the notch in the disk\nœï = setdiff(disk, rec)\nplot(œï)\ncurrent_figure() # hide","category":"section"},{"location":"example-zalesak/#Setting-Up-the-Level-Set-Equation","page":"Zalesak disk","title":"Setting Up the Level Set Equation","text":"We use the level set method to evolve the disk over time with a velocity field that simulates rotation:\n\n# Define the advection equation with a rotational velocity field\neq = LevelSetEquation(;\n    levelset = œï,\n    terms = AdvectionTerm((x, t) -> (-x[2], x[1])),\n    bc = NeumannBC(),\n)","category":"section"},{"location":"example-zalesak/#Evolving-the-Zalesak-Disk","page":"Zalesak disk","title":"Evolving the Zalesak Disk","text":"To evolve the Zalesak disk, we integrate the level set equation over time. We will visualize the evolution using GLMakie:\n\nobs = Observable(eq)\nfig = Figure()\nax = Axis(fig[1, 1])\nplot!(ax, obs)\nframerate = 30\nt0 = current_time(eq)\ntf = 2*œÄ\ntimestamps = range(t0, tf; step = 1 / framerate)\nrecord(fig, joinpath(@__DIR__, \"zalesak2d.gif\"), timestamps) do t_\n    integrate!(eq, t_)\n    return obs[] = eq\nend\n\n(Image: Zalesak 2D)\n\nWe see some small smearing of the disk due to numerical diffusion; this is a common issue, and the situation would be much worse with a low-order upwind scheme.","category":"section"},{"location":"example-zalesak/#Three-dimensional-Zalesak-Disk","page":"Zalesak disk","title":"Three-dimensional Zalesak Disk","text":"The same example can be run in 3D, but the solution takes longer to compute and visualize.\n\nwarning: Performance Warning\nThe 3D example below may take a minute or two to run.\n\n# 3D Zalesak's sphere example\ngrid = CartesianGrid((-1, -1, -1), (1, 1, 1), (50, 50, 50))\ncenter = (-1 / 3, 0, 0)\nradius = 0.5\ndisk = LevelSetMethods.sphere(grid; center, radius)\nrec = LevelSetMethods.rectangle(\n    grid;\n    center = center .+ (0, radius, 0),\n    width = (1 / 3, 1.0, 2),\n)\nœï = setdiff(disk, rec)\neq = LevelSetEquation(;\n    levelset = œï,\n    terms = AdvectionTerm((x, t) -> œÄ * SVector(x[2], -x[1], 0)),\n    bc = NeumannBC(),\n)\nLevelSetMethods.set_makie_theme!()\neq.t = 0\nobs = Observable(eq)\nfig = Figure()\nax = Axis3(fig[1, 1])\nplot!(ax, obs)\nframerate = 30\ntf = 2\ntimestamps = range(0, tf, tf * framerate)\nrecord(fig, joinpath(@__DIR__, \"zalesak3d.gif\"), timestamps) do t_\n    integrate!(eq, t_)\n    return obs[] = eq\nend\n\n(Image: Zalesak 3D)","category":"section"},{"location":"extension-interpolations/#extension-interpolations","page":"Interpolations extension","title":"Interpolations extension","text":"This extension overloads the interpolate function from Interpolations.jl to provide a way to construct a global interpolant from the discrete data in a LevelSet or LevelSetEquation. This can be useful in situations where you want to evaluate the approximate underlying functions at points that are not on the grid.\n\nHere is an example of how to construct such an interpolant:\n\nusing LevelSetMethods, Interpolations\na, b = (-2, -2), (2, 2)\nœï   = LevelSetMethods.star(CartesianGrid(a, b, (50, 50)))\nitp = interpolate(œï, BSpline(Cubic())) # create the interpolant\n\nOnce constructed, the interpolant can be used to evaluate the level-set function anywhere inside the grid:\n\nitp(0.5, 0.5)\n\nThis can be used e.g. to plot the level-set function using Makie:\n\nusing GLMakie\nLevelSetMethods.set_makie_theme!()\nxx = yy = -2:0.01:2\ncontour(xx, yy, [itp(x,y) for x in xx, y in yy]; levels = [0], linewidth = 2)\n\nTrying to evaluate it outside the domain will throw an error:\n\ntry\n  itp(3, 0.1)\ncatch e\n    println(\"Error caught\")\nend\n\nUsing it on three-dimensional level sets is similar:\n\nusing LinearAlgebra\ngrid = CartesianGrid((-1.5, -1.5, -1.5), (1.5, 1.5, 1.5), (50, 50, 50))\nP1, P2 = (-1, 0, 0), (1, 0, 0)\nb = 1.05\nf = (x) -> norm(x .- P1)*norm(x .- P2) - b^2\nœï = LevelSet(f, grid)\nitp = interpolate(œï) # cubic spline by default\nprintln(\"œï(0.5, 0.5, 0.5)   = \", f((0.5, 0.5, 0.5)))\nprintln(\"itp(0.5, 0.5, 0.5) = \", itp(0.5, 0.5, 0.5))","category":"section"},{"location":"#LevelSetMethods","page":"Home","title":"LevelSetMethods","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install the library, run the following command on a Julia REPL:\n\nusing Pkg; Pkg.add(\"LevelSetMethods\")\n\nThis will install the latest tagged version of the package and its dependencies.\n\nFor visualization, you may also want to install one of the Makie backends (we suggest GLMakie for 3D plots and animations).","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This package defines a LevelSetEquation type that can be used to solve partial differential equations of the form\n\nphi_t + underbraceboldsymbolu cdot nabla phi_substacktextadvection  textterm + underbracev nabla phi_substacktextnormal  textterm + underbraceb kappa nabla phi_substacktextcurvature  textterm + underbracetextsign(phi)(nabla phi - 1)_substacktextreinitialization textterm = 0\n\nwhere\n\nphi  mathbbR^d times mathbbR^+ to mathbbR is the level set function\nboldsymbolu mathbbR^d times mathbbR^+  to mathbbR^d is a given (external) velocity field\nv  mathbbR^d times mathbbR^+ to mathbbR is a normal speed\nb  mathbbR^d times mathbbR^+ to mathbbR is a function that multiplies the curvature kappa = nabla cdot (nabla phi  nabla phi)\n\nHere is how it looks in practice to create a simple LevelSetEquation:\n\nusing LevelSetMethods\ngrid = CartesianGrid((-1, -1), (1, 1), (100, 100))\n# œï    = LevelSet(x -> sqrt(2*x[1]^2 + x[2]^2) - 1/2, grid) # a disk\nœï    = LevelSetMethods.dumbbell(grid) # a predefined shape\nùêÆ    = (x,t) -> (-x[2], x[1])\neq   = LevelSetEquation(;\n  terms = (AdvectionTerm(ùêÆ),),\n  levelset = œï,\n  bc = PeriodicBC()\n)\n\nYou can easily plot the current state of your level set equation using the plot function from Makie:\n\nusing GLMakie # loads the MakieExt from LevelSetMethods\nLevelSetMethods.set_makie_theme!() # optional theme customization\nplot(œï)\n\nTo step it in time, we can use the integrate! function:\n\nintegrate!(eq, 1)\n\nThis will advance the solution up to t = 1, modifying œï in the process:\n\nplot(œï)\n\nCreating an animation can be achieved by calling integrate! in a loop and saving the results to a file:\n\nusing GLMakie\ntheme = LevelSetMethods.makie_theme()\nanim = with_theme(theme) do\n    obs = Observable(eq)\n    fig = Figure()\n    ax = Axis(fig[1, 1])\n    plot!(ax, obs)\n    framerate = 30\n    t0 = current_time(eq)\n    tf = t0 + œÄ\n    timestamps = range(t0, tf; step = 1 / framerate)\n    record(fig, joinpath(@__DIR__, \"ls_intro.gif\"), timestamps) do t_\n        integrate!(eq, t_)\n        return obs[] = eq\n    end\nend\n\nHere is what the .gif file looks like:\n\n(Image: Dumbbell)\n\nFor more interesting applications and advanced usage, see the examples section!\n\nnote: Other resources\nThere is an almost one-to-one correspondance between each of the LevelSetTerms described above and individual chapters of the book by Osher and Fedwick on level set methods [1], so users interested in digging deeper into the theory/algorithms are encourage to consult that refenrence. We also drew some inspiration from the great Matlab library ToolboxLS by Ian Mitchell [2].","category":"section"},{"location":"#Going-further","page":"Home","title":"Going further","text":"As illustrated above, the LevelSetEquation type is the main structure of this package. Becoming familiar with its fields and methods is a good starting point to use the package:\n\nTo learn more about the package, you should also check out the following sections:\n\nThe section on terms for a detailed description of each term and their corresponding customizations\nThe section on time integrators for a description of the available time integrators and how to use them\nThe section on boundary conditions for a description of the available boundary conditions and how to use them\n\nFinally, the examples section contains a list of examples that demonstrate some hopefully cool applications.","category":"section"},{"location":"#Bibliography","page":"Home","title":"Bibliography","text":"S.¬†Osher and R.¬†Fedkiw. Level Set Methods and Dynamic Implicit Surfaces. Vol.¬†153 (Springer New York, New York, NY, 2003).\n\n\n\nI.¬†M.¬†Mitchell and others. A toolbox of level set methods. UBC¬†Department¬†of¬†Computer¬†Science¬†Technical¬†Report¬†TR-2007-11 1, 6 (2007).\n\n\n\nG.¬†Allaire, F.¬†Jouve and A.-M.¬†Toader. Structural optimization using sensitivity analysis and a level-set method. Journal¬†of¬†computational¬†physics 194, 363‚Äì393 (2004).\n\n\n\nR.¬†Saye. High-order methods for computing distances to implicitly defined surfaces. Communications¬†in¬†Applied¬†Mathematics¬†and¬†Computational¬†Science 9, 107‚Äì141 (2014).\n\n\n\n","category":"section"},{"location":"#LevelSetMethods.LevelSetEquation","page":"Home","title":"LevelSetMethods.LevelSetEquation","text":"LevelSetEquation(; terms, levelset, boundary_conditions, t = 0, integrator = RK2(),\nreinit = nothing)\n\nCreate a of a level-set equation of the form œï‚Çú + sum(terms) = 0, where each t ‚àà terms is a LevelSetTerm and levelset is the initial LevelSet.\n\nCalling integrate!(ls, tf) will evolve the level-set equation up to time tf, modifying the current_state(eq) and current_time(eq) of the object eq in the process (and therefore the original levelset).\n\nBoundary conditions can be specified in two ways. If a single BoundaryCondition is provided, it will be applied uniformly to all boundaries of the domain. To apply different boundary conditions to each boundary, pass a tuple of the form (bc_x, bc_y, ...) with as many elements as dimensions in the domain. If bc_x is a BoundaryCondition, it will be applied to both boundaries in the x direction. If bc_x is a tuple of two BoundaryConditions, the first will be applied to the left boundary and the second to the right boundary. The same logic applies to the other dimensions.\n\nThe optional parameter t specifies the initial time of the simulation, and integrator is the TimeIntegrator used to evolve the level-set equation.\n\nReinitialization of the level-set function is controlled by the reinit parameter, a Reinitializer object that specifies both the reinitialization algorithm parameters and the frequency (in time steps). By default, no automatic reinitialization is performed. Using this feature requires the ReinitializationExt to be loaded.\n\nusing LevelSetMethods, StaticArrays\ngrid = CartesianGrid((-1, -1), (1, 1), (50, 50))    # define the grid\nœï = LevelSet(x -> x[1]^2 + x[2]^2 - 0.5^2, grid)    # initial shape\nùêÆ = MeshField(x -> SVector(1, 0), grid)             # advection velocity\nterms = (AdvectionTerm(ùêÆ),)            # advection and curvature terms\nbc = PeriodicBC()                                   # periodic boundary conditions\neq = LevelSetEquation(; terms, levelset = œï, bc)    # level-set equation\n\n# output\n\nLevel-set equation given by\n\n \t œï‚Çú + ùêÆ ‚ãÖ ‚àá œï = 0\n\nCurrent time 0.0\n\n\n\n\n\n\n","category":"type"},{"location":"example-shape-optim/#example-shape-optim","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"","category":"section"},{"location":"example-shape-optim/#Isoperimetric-inequality-as-a-shape-optimization-problem","page":"Shape optimization: a primer","title":"Isoperimetric inequality as a shape optimization problem","text":"We consider in this example the isoperimetric inequality which states that among all closed surfaces enclosing a fixed area with volume V_0  0, the sphere is the one with minimal perimeter. We show here how to demonstrate this result through numerical optimization.\n\nwarning: Warning\nThis example is purely illustrative. The optimization method used here has not been extensively tested. Coupling the LevelSetMethods toolbox to any simulation package makes it possible to solve PDE-constrained optimization problems (see for instance [3]).\n\nTo do this, we first define the problem mathematically:\n\n    beginarrayrl\n        displaystylemin_Omega subset mathbbR^d  P(Omega)\n        \n        textuc  V(Omega) = V_0\n    endarrayqquadtext(1)\n\nwhere P(Omega) V(Omega) are the perimeter and volume of Omega defined by\n\n    V(Omega) = int_Omega textdmathbfx\n    quadtextandquad\n    P(Omega) = int_partial Omega textdmathbfs\n    \n\nThe optimization problem text(1) can be solved using the augmented Lagrangian approach by minimizing iteratively the following functional:\n\n    f(Omega) = P(Omega) + lambda (V(Omega) - V_0) + fracmu2 (V(Omega) - V_0)^2\n    qquadtext(2)\n\nwhere mu is a parameter updated during the course of the optimization. To minimize text(2), we use a gradient-based algorithm. For this, we need to define what a small variation of Omega is. As such, for any shape Omega subset mathbbR^d we define (following Hadamard method) its deformation Omega_boldsymboltheta by a small vector field boldsymboltheta in W^1infty(mathbbR^d mathbbR^d) as:\n\n    Omega_boldsymboltheta\n    = (textId + boldsymboltheta)(Omega)\n    = mathbfx + boldsymboltheta(mathbfx) mathbfx in Omega\n\nThe following first-order Taylor expansion can then be obtained:\n\n    f(Omega_boldsymboltheta)\n    =\n    f(Omega)\n    +\n    int_partial Omega\n    left(\n        kappa + (lambda + mu (V(Omega) - V_0))\n    right) boldsymboltheta cdot mathbfn\n    textdmathbfs\n    + o(boldsymboltheta)\n    \n\nIn other words, using boldsymboltheta = - (kappa + (lambda + mu (V(Omega) - V_0))) mathbfn and a small enough coefficient tau  0, f(Omega_tauboldsymboltheta) is necessary smaller than f(Omega).","category":"section"},{"location":"example-shape-optim/#Numerical-solution-using-the-level-set-method","page":"Shape optimization: a primer","title":"Numerical solution using the level-set method","text":"If Omega is given by the level-set function phi_0  R^d to R then one associated with Omega_tauboldsymboltheta is given by phi(cdot tau) solution of\n\n    partial_t phi - kappa nabla phi - (lambda + mu (V(Omega) - V_0)) nabla phi = 0\n\nwith phi(cdot t = 0) = phi_0. In practice, it is easier to deal with deformations of fixed amplitude s, i.e. taumathbftheta_L^infty = delta. The value of tau is therefore set at each iteration as tau = deltamathbftheta_L^infty.\n\nThis optimization method is implemented in the following Julia code:\n\nusing LevelSetMethods\nusing LinearAlgebra\n\na = (-1.0, -1.0)\nb = (+1.0, +1.0)\nn = (50, 50)\ngrid = CartesianGrid(a, b, n)\n\nœï = LevelSetMethods.star(grid)\n\nterm1 = NormalMotionTerm(MeshField(X -> 0.0, grid))\nterm2 = CurvatureTerm(MeshField(X -> -1.0, grid))\nterms = (term1, term2)\n\nbc = NeumannGradientBC()\nintegrator = ForwardEuler(0.5)\neq = LevelSetEquation(; terms, integrator, levelset = œï, t = 0, bc)\n\nusing GLMakie\n\nnit = 200\nanim = with_theme(LevelSetMethods.makie_theme()) do\n    Œª, Œº = 0.0, 0.1\n    c = 1.1\n    V0 = 0.5\n    R0 = sqrt(V0/œÄ)\n    P0 = 2œÄ*R0\n    Œ¥ = 0.25\n\n    eq.t = 0\n    obs = Observable(eq)\n    fig = Figure()\n    ax = Axis(fig[1, 1])\n    plot!(ax, obs)\n    arc!([0; 0], R0, 0, 2œÄ)\n\n    record(fig, joinpath(@__DIR__,\"optimization.gif\"), 1:nit) do it\n        P = LevelSetMethods.perimeter(œï)\n        V = LevelSetMethods.volume(œï)\n\n        term1 = NormalMotionTerm(MeshField(X -> -(Œª + Œº * (V - V0)), grid))\n        eq.terms = (term1, term2)\n\n        œÑ = Œ¥ * LevelSetMethods.compute_cfl(eq.terms, eq.state, eq.t)\n        integrate!(eq, eq.t + œÑ)\n\n        Œª += Œº * (V - V0)\n        Œº *= c\n        return obs[] = eq\n    end\nend\n\n(Image: Optimization)\n\nDifferent values and updates for the lambda and mu coefficients can be used to control the extent to which the optimization focuses on minimizing the objective or satisfying the constraint. Taking a smaller time step can also limit the oscillations observed at the end of optimization.","category":"section"}]
}
