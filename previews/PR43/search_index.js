var documenterSearchIndex = {"docs":
[{"location":"example-zalesak/#zalesak","page":"Zalesak disk","title":"Zalesak disk","text":"","category":"section"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"This example demonstrates the setup and simulation of a Zalesak disk, a standard benchmark in computational fluid dynamics, using the LevelSetMethods.jl.","category":"page"},{"location":"example-zalesak/#Setting-up-the-Grid-and-Disk","page":"Zalesak disk","title":"Setting up the Grid and Disk","text":"","category":"section"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"using LevelSetMethods\nusing GLMakie\nLevelSetMethods.set_makie_theme!()","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"First, we create a Cartesian grid to represent the computational domain. We define a circular disk with a rectangular cut to form the Zalesak disk.","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"# Define the computational grid\ngrid = CartesianGrid((-1.5, -1.5), (1.5, 1.5), (100, 100))\n# Define the center and radius of the circular disk\ncenter = (-0.75, 0)\nradius = 0.5\n# Define the height and width of the rectangular notch\nh = 1.0\nw = 0.2\n# Create the circular disk and rectangular notch\ndisk = LevelSetMethods.circle(grid; center, radius)\nrec = LevelSetMethods.rectangle(grid; center = center .- (0, radius), width = (w, h))\n# Use set difference to carve out the notch in the disk\nœï = setdiff(disk, rec)\nplot(œï)\ncurrent_figure() # hide","category":"page"},{"location":"example-zalesak/#Setting-Up-the-Level-Set-Equation","page":"Zalesak disk","title":"Setting Up the Level Set Equation","text":"","category":"section"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"We use the level set method to evolve the disk over time with a velocity field that simulates rotation:","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"# Define the advection equation with a rotational velocity field\neq = LevelSetEquation(;\n    levelset = œï,\n    terms = AdvectionTerm((x, t) -> (-x[2], x[1])),\n    bc = NeumannBC(),\n)","category":"page"},{"location":"example-zalesak/#Evolving-the-Zalesak-Disk","page":"Zalesak disk","title":"Evolving the Zalesak Disk","text":"","category":"section"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"To evolve the Zalesak disk, we integrate the level set equation over time. We will visualize the evolution using GLMakie:","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"obs = Observable(eq)\nfig = Figure()\nax = Axis(fig[1, 1])\nplot!(ax, obs)\nframerate = 30\nt0 = current_time(eq)\ntf = 2*œÄ\ntimestamps = range(t0, tf; step = 1 / framerate)\nrecord(fig, joinpath(@__DIR__, \"zalesak2d.gif\"), timestamps) do t_\n    integrate!(eq, t_)\n    return obs[] = eq\nend","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"(Image: Zalesak 2D)","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"We see some small smearing of the disk due to numerical diffusion; this is a common issue, and the situation would be much worse with a low-order upwind scheme.","category":"page"},{"location":"example-zalesak/#Three-dimensional-Zalesak-Disk","page":"Zalesak disk","title":"Three-dimensional Zalesak Disk","text":"","category":"section"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"The same example can be run in 3D, but the solution takes longer to compute and visualize.","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"warning: Performance Warning\nThe 3D example below may take a minute or two to run.","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"using LevelSetMethods\nusing GLMakie\nLevelSetMethods.set_makie_theme!()","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"# 3D Zalesak's sphere example\ngrid = CartesianGrid((-1, -1, -1), (1, 1, 1), (50, 50, 50))\ncenter = (-1 / 3, 0, 0)\nradius = 0.5\ndisk = LevelSetMethods.sphere(grid; center, radius)\nrec = LevelSetMethods.rectangle(\n    grid;\n    center = center .+ (0, radius, 0),\n    width = (1 / 3, 1.0, 2),\n)\nœï = setdiff(disk, rec)\neq = LevelSetEquation(;\n    levelset = œï,\n    terms = AdvectionTerm((x, t) -> œÄ * SVector(x[2], -x[1], 0)),\n    bc = NeumannBC(),\n)\nLevelSetMethods.set_makie_theme!()\neq.t = 0\nobs = Observable(eq)\nfig = Figure()\nax = Axis3(fig[1, 1])\nplot!(ax, obs)\nframerate = 30\ntf = 2\ntimestamps = range(0, tf, tf * framerate)\nrecord(fig, joinpath(@__DIR__, \"zalesak3d.gif\"), timestamps) do t_\n    integrate!(eq, t_)\n    return obs[] = eq\nend","category":"page"},{"location":"example-zalesak/","page":"Zalesak disk","title":"Zalesak disk","text":"(Image: Zalesak 3D)","category":"page"},{"location":"extension-makie/#extension-makie","page":"Makie extension","title":"Makie extension","text":"","category":"section"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"Makie can be used to visualize levelset functions in both 2 and 3 dimensions. After loading one of the Makie backends (we recomment GLMakie for 3D), you can simply call plot on the levelset function to visualize it. For example:","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"using LevelSetMethods, GLMakie\ngrid = CartesianGrid((-2, -2), (2, 2), (100, 100))\nœï = LevelSetMethods.star(grid)\nplot(œï)","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"By default, only the zero level-set is plotted as a contour line. For more control, simply call the contour (or contourf) function from Makie directly. For example:","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"contour(œï; levels = [-0.5, 0, 0.5], labels = true)","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"Although you can manually customize the Axis attributes for the plot, LevelSetMethods provides a Theme with some reasonable defaults for plotting levelset functions:","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"theme = LevelSetMethods.makie_theme()\nwith_theme(theme) do\n  plot(œï)\nend","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"In 3D, the plot function will plot the zero level-set as an isosurface. For example:","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"using LevelSetMethods, GLMakie, LinearAlgebra\ngrid = CartesianGrid((-1.5, -1.5, -1.5), (1.5, 1.5, 1.5), (50, 50, 50))\nP1, P2 = (-1, 0, 0), (1, 0, 0)\nb = 1.05\nœï = LevelSet(grid) do x\n  norm(x .- P1)*norm(x .- P2) - b^2\nend\ntheme = LevelSetMethods.makie_theme()\nwith_theme(theme) do\n  plot(œï)\nend","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"Once again, you can manually customize the options by calling the volume function from Makie directly:","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"with_theme(theme) do\n  volume(œï; algorithm = :iso, isovalue = 0.5)\nend","category":"page"},{"location":"extension-makie/","page":"Makie extension","title":"Makie extension","text":"tip: Plotting a `LevelSetEquation`\nCalling plot on a LevelSetEquation defaults to plotting the LevelSet given by its current_state; exactly the same as calling plot(current_state(equation)).","category":"page"},{"location":"extension-mmg/#extension-mmg","page":"MMG extension","title":"MMG extension","text":"","category":"section"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"This extension provides functions to generate meshes of levelset functions using MMG. It define two methods: export_volume_mesh and export_surface_mesh. For both of them, it is possible to control the size of the generated mesh using the following optional parameters:","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"hgrad control the growth ratio between two adjacent edges.\nhmin and hmax control the edge sizes to be (respectively) greater than the hmin parameter and lower than the hmax one.\nhausd control the maximal distance between the piecewise linear representation of the boundary and the reconstructed ideal boundary.","category":"page"},{"location":"extension-mmg/#Generation-of-2D-and-3D-mesh-from-a-level-set","page":"MMG extension","title":"Generation of 2D and 3D mesh from a level-set","text":"","category":"section"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"For 2 and 3 dimensional Cartesian levelset, one can use the export_volume_mesh function to generate meshes. This method relies on the mmg2d_O3 and mmg3d_O3 utilities. Example in 2D:","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"using LevelSetMethods, MMG_jll\ngrid = CartesianGrid((-2, -2), (2, 2), (50, 50))\nœï = LevelSetMethods.star(grid)\nvolume_mesh2d = LevelSetMethods.export_volume_mesh(œï, joinpath(@__DIR__, \"volume2D.mesh\"))","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"You can then use e.g. Gmsh to visualize the mesh:","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"using GLMakie # hide\nGLMakie.closeall() # hide\nusing Gmsh\ntry\n  gmsh.initialize()\n  gmsh.option.setNumber(\"General.Verbosity\", 0)\n  gmsh.open(volume_mesh2d)\n  gmsh.fltk.initialize()\n  gmsh.write(joinpath(@__DIR__, \"volume2d.png\"))\n  gmsh.fltk.finalize()\nfinally\n  gmsh.finalize()\nend\n","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"(Image: Volume2D)","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"And similarly in 3D:","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"using LevelSetMethods, MMG_jll\ngrid = CartesianGrid((-1, -1, -1), (+1, +1, +1), (20, 20, 20))\nœï = LevelSetMethods.sphere(grid; radius = 0.5)\nvolume_mesh3d = LevelSetMethods.export_volume_mesh(œï, joinpath(@__DIR__, \"volume3d.mesh\"))","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"(Image: Volume3D)","category":"page"},{"location":"extension-mmg/#Generation-of-3D-surface-mesh-with-MarchingCubes.jl","page":"MMG extension","title":"Generation of 3D surface mesh with MarchingCubes.jl","text":"","category":"section"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"Using the mmgs_O3 utility, the MarchingCubes.jl library and the export_surface_mesh function it is possible to obtain a mesh of the levelset contour.","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"using LevelSetMethods, MMG_jll, MarchingCubes\ngrid = CartesianGrid((-2, -1, -1), (+2, +1, +1), (40, 20, 20))\nœï‚ÇÅ = LevelSetMethods.sphere(grid; radius = 0.5, center = (-1, 0, 0))\nœï‚ÇÇ = LevelSetMethods.sphere(grid; radius = 0.5, center = (+1, 0, 0))\nœï‚ÇÉ = LevelSetMethods.rectangle(grid; center = (0, 0, 0), width = (2, 0.25, 0.25))\nœï  = œï‚ÇÅ ‚à™ œï‚ÇÇ ‚à™ œï‚ÇÉ\nsurf_mesh3d = LevelSetMethods.export_surface_mesh(œï, joinpath(@__DIR__,\"surface3D.mesh\"); hausd = 1.2, hmax = 1.0)","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"Again, to visualize it we can use Gmsh:","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"using GLMakie # hide\nGLMakie.closeall() # hide\nusing Gmsh\ntry\n  gmsh.initialize()\n  gmsh.option.setNumber(\"General.Verbosity\", 0)\n  gmsh.open(surf_mesh3d)\n  gmsh.fltk.initialize()\n  gmsh.write(joinpath(@__DIR__, \"surface3d.png\"))\n  gmsh.fltk.finalize()\nfinally\n  gmsh.finalize()\nend\n","category":"page"},{"location":"extension-mmg/","page":"MMG extension","title":"MMG extension","text":"(Image: Surface3D)","category":"page"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Modules = [LevelSetMethods,\n          Base.get_extension(LevelSetMethods, :MakieExt),\n          Base.get_extension(LevelSetMethods, :MMGSurfaceExt),\n          Base.get_extension(LevelSetMethods, :MMGVolumeExt)\n          ]","category":"page"},{"location":"95-reference/#LevelSetMethods.AbstractMesh","page":"Reference","title":"LevelSetMethods.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract mesh structure in dimension N with primite data of type T.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.AdvectionTerm","page":"Reference","title":"LevelSetMethods.AdvectionTerm","text":"AdvectionTerm(ùêÆ, scheme = WENO5())\n\nAdvection term representing  ùêÆ ‚ãÖ ‚àáœï. Available schemes are Upwind and WENO5.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.BoundaryCondition","page":"Reference","title":"LevelSetMethods.BoundaryCondition","text":"abstract type BoundaryCondition\n\nTypes used to specify boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.CartesianGrid-Tuple{Any, Any, Any}","page":"Reference","title":"LevelSetMethods.CartesianGrid","text":"CartesianGrid(lc, hc, n)\n\nCreate a uniform cartesian grid with lower corner lc, upper corner hc and and n nodes in each direction.\n\nExamples\n\nusing LevelSetMethods\na = (0, 0)\nb = (1, 1)\nn = (10, 4)\ngrid = CartesianGrid(a, b, n)\n\n# output\n\nCartesianGrid{2, Int64}([0, 0], [1, 1], (10, 4))\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.CartesianMeshField","page":"Reference","title":"LevelSetMethods.CartesianMeshField","text":"const CartesianMeshField{V,M<:CartesianGrid} = MeshField{V,M}\n\nMeshField over a CartesianGrid.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.CurvatureTerm","page":"Reference","title":"LevelSetMethods.CurvatureTerm","text":"struct CurvatureTerm{V,M} <: LevelSetTerm\n\nLevel-set curvature term representing bŒ∫|‚àáœï|, where Œ∫ = ‚àá ‚ãÖ (‚àáœï/|‚àáœï|) is the curvature.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.DirichletBC","page":"Reference","title":"LevelSetMethods.DirichletBC","text":"struct DirichletBC{T} <: BoundaryCondition\n\nA Dirichlet boundary condition taking values of f(x) at the boundary.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.LevelSet","page":"Reference","title":"LevelSetMethods.LevelSet","text":"LevelSet\n\nAlias for MeshField with vals as an AbstractArray of Reals.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.LevelSetEquation-Tuple{}","page":"Reference","title":"LevelSetMethods.LevelSetEquation","text":"LevelSetEquation(; terms, levelset, boundary_conditions, t = 0, integrator = RK3())\n\nCreate a of a level-set equation of the form œï‚Çú + sum(terms) = 0, where each t ‚àà terms is a LevelSetTerm and levelset is the initial LevelSet.\n\nCalling integrate!(ls, tf) will evolve the level-set equation up to time tf, modifying the current_state(eq) and current_time(eq) of the object eq in the process (and therefore the original levelset).\n\nBoundary conditions can be specified in two ways. If a single BoundaryCondition is provided, it will be applied uniformly to all boundaries of the domain. To apply different boundary conditions to each boundary, pass a tuple of the form (bc_x, bc_y, ...) with as many elements as dimensions in the domain. If bc_x is a BoundaryCondition, it will be applied to both boundaries in the x direction. If bc_x is a tuple of two BoundaryConditions, the first will be applied to the left boundary and the second to the right boundary. The same logic applies to the other dimensions.\n\nThe optional parameter t specifies the initial time of the simulation, and integrator is the TimeIntegrator used to evolve the level-set equation.\n\nusing LevelSetMethods, StaticArrays\ngrid = CartesianGrid((-1, -1), (1, 1), (50, 50))    # define the grid\nœï = LevelSet(x -> x[1]^2 + x[2]^2 - 0.5^2, grid)    # initial shape\nùêÆ = MeshField(x -> SVector(1, 0), grid)             # advection velocity\nterms = (AdvectionTerm(ùêÆ),)            # advection and curvature terms\nbc = PeriodicBC()                                   # periodic boundary conditions\neq = LevelSetEquation(; terms, levelset = œï, bc)    # level-set equation\n\n# output\n\nLevel-set equation given by\n\n \t œï‚Çú + ùêÆ ‚ãÖ ‚àá œï = 0\n\nCurrent time 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.LevelSetTerm","page":"Reference","title":"LevelSetMethods.LevelSetTerm","text":"abstract type LevelSetTerm\n\nA typical term in a level-set evolution equation.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.MeshField","page":"Reference","title":"LevelSetMethods.MeshField","text":"struct MeshField{V,M,B}\n\nA field described by its discrete values on a mesh.\n\nBase.getindex of an MeshField is overloaded to handle indices that lie outside the CartesianIndices of its MeshField by using bcs.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.MeshField-Tuple{Function, Any}","page":"Reference","title":"LevelSetMethods.MeshField","text":"MeshField(f::Function, m)\n\nCreate a MeshField by evaluating a function f on a mesh m.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.NeumannBC","page":"Reference","title":"LevelSetMethods.NeumannBC","text":"struct NeumannBC <: BoundaryCondition\n\nHomogenous Neumann boundary condition, i.e. ‚àÇx œï = 0.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.NeumannGradientBC","page":"Reference","title":"LevelSetMethods.NeumannGradientBC","text":"struct NeumannGradientBC <: BoundaryCondition\n\nHomogenous Neumann gradient boundary condition, i.e. ‚àÇxx œï = 0.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.NormalMotionTerm","page":"Reference","title":"LevelSetMethods.NormalMotionTerm","text":"struct NormalMotionTerm{V,M} <: LevelSetTerm\n\nLevel-set advection term representing  v |‚àáœï|. This LevelSetTerm should be used for internally generated velocity fields; for externally generated velocities you may use AdvectionTerm instead.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.PeriodicBC","page":"Reference","title":"LevelSetMethods.PeriodicBC","text":"struct PeriodicBC <: BoundaryCondition\n\nSingleton type representing periodic boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.RK2","page":"Reference","title":"LevelSetMethods.RK2","text":"struct RK2\n\nSecond order total variation dimishing Runge-Kutta scheme, also known as Heun's predictor-corrector method.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.RK3","page":"Reference","title":"LevelSetMethods.RK3","text":"struct RK3\n\nThird order total variation dimishing Runge-Kutta scheme.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.ReinitializationTerm","page":"Reference","title":"LevelSetMethods.ReinitializationTerm","text":"struct ReinitializationTerm <: LevelSetTerm\n\nLevel-set term representing  sign(œï) (|‚àáœï| - 1). This LevelSetTerm should be used for reinitializing the level set into a signed distance function: for a sufficiently large number of time steps this term allows one to solve the Eikonal equation |‚àáœï| = 1.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.TimeIntegrator","page":"Reference","title":"LevelSetMethods.TimeIntegrator","text":"abstract type TimeIntegrator end\n\nAbstract type for time integrators. See subtypes(TimeIntegrator) for a list of available time integrators.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LevelSetMethods.D2-Tuple{Any, Any, Any}","page":"Reference","title":"LevelSetMethods.D2","text":"D2(œï::CartesianMeshField,I,dims)\n\nFinite difference scheme for second order derivative at grid point I along the dimensions dims.\n\nIf dims[1] == dims[2], it is more efficient to call D2‚Å∞(œï,I,dims[1]).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D2‚Å∞-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D2‚Å∞","text":"D2‚Å∞(œï::CartesianMeshField,I,dim)\n\nCentered finite difference scheme for second order derivative at grid point I along dimension dim. E.g. if dim=1, this approximates ‚àÇ‚Çì‚Çì.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D2‚Å∫‚Å∫-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D2‚Å∫‚Å∫","text":"D2‚Å∫‚Å∫(œï::CartesianMeshField,I,dim)\n\nUpward finite difference scheme for second order derivative at grid point I along dimension dim. E.g. if dim=1, this approximates ‚àÇ‚Çì‚Çì.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D2‚Åª‚Åª-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D2‚Åª‚Åª","text":"D2‚Åª‚Å∫(œï::CartesianMeshField,I,dim)\n\nBackward finite difference scheme for second order derivative at grid point I along dimension dim. E.g. if dim=1, this approximates ‚àÇ‚Çì‚Çì.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D‚Å∞-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D‚Å∞","text":"D‚Å∞(œï::CartesianMeshField,I,dim)\n\nCentered finite difference scheme for first order derivative at grid point I along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D‚Å∫-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D‚Å∫","text":"D‚Å∫(œï::CartesianMeshField,I,dim)\n\nForward finite difference scheme for first order derivative at grid point I along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.D‚Åª-Tuple{MeshField{V, M} where {V, M<:CartesianGrid}, Any, Any}","page":"Reference","title":"LevelSetMethods.D‚Åª","text":"D‚Åª(œï::CartesianMeshField,I,dim)\n\nBackward finite difference scheme for first order derivative at grid point I along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.curvature-Tuple{LevelSet, Any}","page":"Reference","title":"LevelSetMethods.curvature","text":"curvature(œï::LevelSet, I)\n\nCompute the mean curvature of œï at I using Œ∫ = ‚àá ‚ãÖ (‚àáœï / |‚àáœï|). We use the formula Œ∫ = (Œîœï |‚àáœï|^2 - ‚àáœï^T Hœï ‚àáœï) / |‚àáœï|^3 with first order finite differences. https://en.wikipedia.org/wiki/Meancurvature#Implicitformofmean_curvature\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.curvature-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.curvature","text":"curvature(œï::LevelSet)\n\nCompute the mean curvature of œï at I using Œ∫ = ‚àá ‚ãÖ (‚àáœï / |‚àáœï|). See curvature(œï::LevelSet, I) for more details.\n\nusing LevelSetMethods\nN = 50\ngrid = CartesianGrid((-1, -1), (1, 1), (N, N))\nœï = LevelSetMethods.star(grid)\nusing GLMakie\ncoeff = exp.(-40.0 * values(œï) .^ 2)\nŒ∫ = curvature(œï) .* coeff\nxs = LevelSetMethods.grid1d(grid, 1)\nys = LevelSetMethods.grid1d(grid, 2)\nfig, ax, hm = heatmap(xs, ys, Œ∫)\nColorbar(fig[:, end+1], hm)\ncontour!(xs, ys, values(œï); levels = [0.0])\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.gradient-Tuple{LevelSet, Any}","page":"Reference","title":"LevelSetMethods.gradient","text":"gradient(œï::LevelSet, I)\n\nReturn the gradient vector ‚àáœï of œï at I\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.hessian-Tuple{LevelSet, Any}","page":"Reference","title":"LevelSetMethods.hessian","text":"hessian(œï::LevelSet, I)\n\nReturn the Hessian matrix Hœï of œï at I\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.integrate!","page":"Reference","title":"LevelSetMethods.integrate!","text":"integrate!(ls::LevelSetEquation,tf,Œît=Inf)\n\nIntegrate the LevelSetEquation ls up to time tf, mutating the levelset and current_time of the object ls in the process.\n\nAn optional parameter Œît can be passed to specify a maximum time-step allowed for the integration. Note that the internal time-steps taken to evolve the level-set up to tf may be smaller than Œît due to stability reasons related to the terms and integrator employed.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LevelSetMethods.makie_theme","page":"Reference","title":"LevelSetMethods.makie_theme","text":"makie_theme()\n\nReturn a Makie theme for plots of level-set functions.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LevelSetMethods.normal-Tuple{LevelSet, Any}","page":"Reference","title":"LevelSetMethods.normal","text":"normal(œï::LevelSet, I)\n\nCompute the unit exterior normal vector of œï at I using n = ‚àáœï/|‚àáœï|\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.normal-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.normal","text":"normal(œï::LevelSet)\n\nCompute the unit exterior normal vector of œï using n = ‚àáœï/|‚àáœï|\n\nusing LevelSetMethods\nN = 50\ngrid = CartesianGrid((-1, -1), (1, 1), (N, N))\nœï = LevelSetMethods.star(grid)\nusing GLMakie\nn = normal(œï)\nxs = LevelSetMethods.grid1d(grid, 1)\nys = LevelSetMethods.grid1d(grid, 2)\ncoeff = exp.(-40.0 * values(œï) .^ 2)\nus = getindex.(n, 1) .* coeff\nvs = getindex.(n, 2) .* coeff\narrows(xs, ys, us, vs; arrowsize = 10 * vec(coeff), lengthscale = 2.0 / (N - 1))\ncontour!(xs, ys, values(œï); levels = [0.0])\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.perimeter-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.perimeter","text":"perimeter(œï::LevelSet)\n\nCompute the perimeter area of the level-set function.\n\nNote: this function does not compute the perimeter on the borders of the domain.\n\nusing LevelSetMethods\nR = 0.5\nS0 = 2œÄ * R\ngrid = CartesianGrid((-1, -1), (1, 1), (200, 200))\nœï = LevelSetMethods.circle(grid; center = (0, 0), radius = R)\nLevelSetMethods.perimeter(œï), S0\n\n# output\n\n(3.1426415491430366, 3.141592653589793)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.set_makie_theme!","page":"Reference","title":"LevelSetMethods.set_makie_theme!","text":"set_makie_theme!()\n\nSet the Makie theme to LevelSetMethods.makie_theme().\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LevelSetMethods.volume-Tuple{LevelSet}","page":"Reference","title":"LevelSetMethods.volume","text":"volume(œï::LevelSet)\n\nCompute the volume of the level-set function.\n\nusing LevelSetMethods\nR = 0.5\nV0 = œÄ * R^2\ngrid = CartesianGrid((-1, -1), (1, 1), (200, 200))\nœï = LevelSetMethods.circle(grid; center = (0, 0), radius = R)\nLevelSetMethods.volume(œï), V0\n\n# output\n\n(0.7854362890190668, 0.7853981633974483)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.export_surface_mesh-Tuple{LevelSet, String}","page":"Reference","title":"LevelSetMethods.export_surface_mesh","text":"export_surface_mesh(œï::LevelSet, output::String;\n    hgrad = nothing, hmin = nothing, hmax = nothing, hausd = nothing)\n\nCompute a mesh of the LevelSet œï zero contour using MMGs_O3.\n\nhgrad control the growth ratio between two adjacent edges\n\nhmin and hmax control the edge sizes to be (respectively) greater than the hmin parameter and lower than the hmax one\n\nhausd control the maximal distance between the piecewise linear representation of the boundary and the reconstructed ideal boundary\n\nnote: Note\nOnly works for 3 dimensional level-set.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.export_surface_mesh-Tuple{LevelSetEquation, Vararg{Any}}","page":"Reference","title":"LevelSetMethods.export_surface_mesh","text":"export_surface_mesh(eq::LevelSetEquation, args...; kwargs...)\n\nCall export_surface_mesh on current_state(eq).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.export_volume_mesh-Tuple{LevelSet, String}","page":"Reference","title":"LevelSetMethods.export_volume_mesh","text":"export_volume_mesh(œï::LevelSet, output::String;\n    hgrad = nothing, hmin = nothing, hmax = nothing, hausd = nothing)\n\nCompute a mesh of the domains associated with LevelSet eq using either MMG2dO3 or MMG3dO3.\n\nhgrad control the growth ratio between two adjacent edges.\n\nhmin and hmax control the edge sizes to be (respectively) greater than the hmin parameter and lower than the hmax one.\n\nhausd control the maximal distance between the piecewise linear representation of the boundary and the reconstructed ideal boundary.\n\nFor more information, see the official MMG documentation.\n\nnote: Note\nOnly works for 2 and 3 dimensional level-set.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LevelSetMethods.export_volume_mesh-Tuple{LevelSetEquation, Vararg{Any}}","page":"Reference","title":"LevelSetMethods.export_volume_mesh","text":"export_volume_mesh(eq::LevelSetEquation, output; kwargs...)\n\nCall export_volume_mesh on current_state(eq).\n\n\n\n\n\n","category":"method"},{"location":"time-integrators/#time-integrators","page":"Time integration","title":"Time integration","text":"","category":"section"},{"location":"time-integrators/","page":"Time integration","title":"Time integration","text":"The following options are available for time integration:","category":"page"},{"location":"time-integrators/","page":"Time integration","title":"Time integration","text":"using LevelSetMethods\nusing InteractiveUtils # hide\nsubtypes(LevelSetMethods.TimeIntegrator)","category":"page"},{"location":"time-integrators/","page":"Time integration","title":"Time integration","text":"These are all explicit schemes, and therefore a sufficiently small time step, dependant on the LevelSetTerm being used, is required to ensure stability. We recommend using the third order RK3 scheme for most applications.","category":"page"},{"location":"boundary-conditions/#boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"The following boundary conditions are available:","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"using LevelSetMethods\nusing InteractiveUtils # hide\nsubtypes(LevelSetMethods.BoundaryCondition)","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"When constructing a level-set equation, you can pass up to 2^d boundary conditions, where d is the dimension of the space. The following convention is followed:","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"if you pass a single boundary condition, it is applied to all 2^d boundaries\nif you pass a vector bcs of d boundary conditions, the i-th element is applied to the i-th direction. Two options are then possible:\nbcs[i] is a single boundary condition, in which case it is applied to both boundaries in the i-th direction\nbcs[i] is a tuple of two boundary conditions, in which case the first element is applied to the lower/left boundary and the second element to the upper/right boundary","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Here is how it looks in practice:","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"using LevelSetMethods, GLMakie\ngrid = CartesianGrid((-1,-1), (1,1), (100, 100))\nœï‚ÇÄ    = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid)\nbc   = PeriodicBC()\neq   = LevelSetEquation(; levelset = deepcopy(œï‚ÇÄ), bc, terms = AdvectionTerm((x,t) -> (1,0)))\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"Changing PeriodicBC() to NeumannBC() gives allows for the level-set to \"leak\" out of the domain:","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"eq   = LevelSetEquation(; levelset = deepcopy(œï‚ÇÄ), bc = NeumannBC(), terms = AdvectionTerm((x,t) -> (1,0)))\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"To combine both boundary conditions you can use","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"bc = (NeumannBC(), PeriodicBC()) # Neumann in x, periodic in y\neq   = LevelSetEquation(; levelset = deepcopy(œï‚ÇÄ), bc, terms = AdvectionTerm((x,t) -> (1,1)))\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig","category":"page"},{"location":"boundary-conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"For more details on each boundary condition, see the docstring for the corresponding type.","category":"page"},{"location":"terms/#terms","page":"Level-set terms","title":"Level-set terms","text":"","category":"section"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"A level-set equation is given by","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"  phi_t + sum_n textttterm_n = 0","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"where each textttterm_n is a LevelSetTerm object. The following terms are available:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"using LevelSetMethods\nusing InteractiveUtils # hide\nsubtypes(LevelSetMethods.LevelSetTerm)","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"Here we investigate the meaning of each term, and how they can be used to model different phenomena.","category":"page"},{"location":"terms/#advection","page":"Level-set terms","title":"Advection","text":"","category":"section"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"The simplest term is the advection term, which is given by","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"  mathbfu cdot nabla phi","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"where mathbfu is a velocity field. This term models the transport of the level-set by an external velocity field (see [1, Chapter 3]). You can construct an advection term using the AdvectionTerm structure:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"using LevelSetMethods, StaticArrays\ngrid = CartesianGrid((-1,-1), (1,1), (100, 100))\nùêÆ = MeshField(x -> SVector(1,0), grid)\nAdvectionTerm(ùêÆ)","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"In the example above we passed a MeshField object to the AdvectionTerm constructor, meaning that the velocity field is simply a vector of values at each grid point. This is useful if your velocity field is time-independent, or if you only know it at grid points. Lets construct a level-set equation with an advection term:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"œï‚ÇÄ = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid)\neq = LevelSetEquation(; terms = (AdvectionTerm(ùêÆ),), levelset = œï‚ÇÄ, bc = PeriodicBC())","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"To see how the advection term affects the level-set, we can solve the equation for a few time steps:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"using GLMakie\nLevelSetMethods.set_makie_theme!()\nfig = Figure(; size = (1200, 300))\n# create a 2 x 2 figure\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    I = CartesianIndices((2,2))[n]\n    integrate!(eq, t)\n    # ax = Axis(fig[I[1],I[2]])\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"In the example above we see that the level-set is advected to the right. If we wanted to have instead a time-dependent velocity field, we could pass a function to the AdvectionTerm, and the velocity field would be computed at each time step. For example:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"œï‚ÇÄ = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid)\neq = LevelSetEquation(; terms = (AdvectionTerm((x,t) -> SVector(x[1]^2, 0)),), levelset = œï‚ÇÄ, bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\n# create a 2 x 2 figure\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    I = CartesianIndices((2,2))[n]\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"Note that the velocity function must accept two arguments: the spatial coordinates x, which is an abstract vector of length d, and the time t. Furthermore, it should return a vector of length d.","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"Besides the velocity field, the AdvectionTerm constructor also accepts a scheme as a second argument to specify the discretization scheme. The available options are:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"Upwind(): first-order upwind scheme\nWENO5(): fifth-order WENO scheme (default)","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"The WENO scheme is more expensive but much more accurate and is usually preferable to the upwind scheme, which introduces significant numerical diffusion. To see their differences, let us compare both schemes for a purely rotational velocity field:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"œï‚ÇÄ = LevelSetMethods.dumbbell(grid) # pre-defined level-set\nùêÆ  = MeshField(grid) do (x,y)\n    SVector(-y, x)\nend\neq_upwind = LevelSetEquation(; terms = AdvectionTerm(ùêÆ, Upwind()), levelset = deepcopy(œï‚ÇÄ), bc = PeriodicBC())\neq_weno   = LevelSetEquation(; terms = AdvectionTerm(ùêÆ), levelset  = deepcopy(œï‚ÇÄ), bc = PeriodicBC())\nfig = Figure(size = (1000, 400))\nax = Axis(fig[1,1], title = \"Initial\")\nplot!(ax, eq_upwind)\n# do half a revolution\ntf = œÄ\nax = Axis(fig[1,2], title = \"Upwind (final time)\")\nintegrate!(eq_upwind, tf)\nplot!(ax, eq_upwind)\nax = Axis(fig[1,3], title = \"WENO5 (final time)\")\nintegrate!(eq_weno, tf)\nplot!(ax, eq_weno)\nfig","category":"page"},{"location":"terms/#normal-motion","page":"Level-set terms","title":"Normal motion","text":"","category":"section"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"The normal motion term is given by","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"  v nabla phi","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"where v is a scalar field. This term models the motion of the level-set in the normal direction (see [1, Chapter 6]). Here is an example of how to use it:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"using LevelSetMethods\nusing GLMakie\ngrid = CartesianGrid((-2,-2), (2,2), (100, 100))\nœï = LevelSetMethods.star(grid)\neq = LevelSetEquation(; terms = (NormalMotionTerm((x,t) -> 0.5),), levelset = œï, bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig","category":"page"},{"location":"terms/#curvature","page":"Level-set terms","title":"Curvature motion","text":"","category":"section"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"This terms models the motion of the level-set in the normal direction with a velocity that is proportional to the mean curvature:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"  b kappa nabla phi","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"where kappa = nabla cdot (nabla phi  nabla phi) is the mean curvature. Note that the coefficient b should be negative; a positive value of b would yield an ill-posed evolution problem (akin to a negative diffusion coefficient).","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"Here is the classic example of motion by mean curavature for a spiral-like level-set:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"using LevelSetMethods, GLMakie\ngrid = CartesianGrid((-1,-1), (1,1), (100, 100))\n# create a spiral level-set\nd = 1\nr0 = 0.5\nŒ∏0 = -œÄ / 3\nŒ± = œÄ / 100.0\nR = [cos(Œ±) -sin(Œ±); sin(Œ±) cos(Œ±)]\nM = R * [1/0.06^2 0; 0 1/(4œÄ^2)] * R'\nœï = LevelSet(grid) do (x, y)\n    r = sqrt(x^2 + y^2)\n    Œ∏ = atan(y, x)\n    result = 1e30\n    for i in 0:4\n        Œ∏1 = Œ∏ + (2i - 4) * œÄ\n        v = [r - r0; Œ∏1 - Œ∏0]\n        result = min(result, sqrt(v' * M * v) - d)\n    end\n    return result\nend\neq = LevelSetEquation(; terms = (CurvatureTerm((x,t) -> -0.1),), levelset = œï, bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.1, 0.2, 0.3])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    plot!(ax, eq)\nend\nfig","category":"page"},{"location":"terms/#reinitialization","page":"Level-set terms","title":"Reinitialization term","text":"","category":"section"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"The reinitialization term is given by","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"  phi_t + textsign(phi) left( nabla phi - 1 right) = 0","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"This term is used to ensure that the level-set function remains close to a signed distance function, which is sometimes important for numerical stability. The idea of the evolution equation above is to penalize the deviation of the level-set from a signed distance function, where nabla phi = 1, without changing the zero level-set. In practice a smeared sign function is used; see [1, Chapter 7] for more details.","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"Here is an example of how to use the reinitialization term to obtain a signed distance function from a level-set. Let us first create a level-set that is not a signed distance, and its signed distance function:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"using LevelSetMethods, GLMakie\ngrid = CartesianGrid((-1,-1), (1,1), (100, 100))\nœï = LevelSet(x -> x[1]^2 + x[2]^2 - 0.5^2, grid) # circle level-set, but not a signed distance function\nsdf = LevelSet(x -> sqrt(x[1]^2 + x[2]^2) - 0.5, grid) # signed distance function\nLevelSetMethods.set_makie_theme!()\nfig = Figure(; size = (800, 400))\nax = Axis(fig[1,1], title = \"Signed distance function\")\ncontour!(ax, sdf; levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\nax = Axis(fig[1,2], title = \"œï at t = 0\")\ncontour!(ax, œï, levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\nfig","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"We will now evolve the level-set using the reinitialization term:","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"eq = LevelSetEquation(; terms = (ReinitializationTerm(),), levelset = œï, bc = PeriodicBC())\nfig = Figure(; size = (1200, 300))\nfor (n,t) in enumerate([0.0, 0.25, 0.5, 0.75])\n    integrate!(eq, t)\n    ax = Axis(fig[1,n], title = \"t = $t\")\n    contour!(ax, LevelSetMethods.current_state(eq); levels = [0.25, 0, 0.5], labels = true, labelsize = 14)\nend\nfig","category":"page"},{"location":"terms/","page":"Level-set terms","title":"Level-set terms","text":"Note that œï converges to the signed distance function sdf shown in the first figure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LevelSetMethods","category":"page"},{"location":"#LevelSetMethods","page":"Home","title":"LevelSetMethods","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the library, run the following command on a Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"LevelSetMethods\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install the latest tagged version of the package and its dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For visualization, you may also want to install one of the Makie backends (we suggest GLMakie for 3D plots and animations).","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package defines a LevelSetEquation type that can be used to solve partial differential equations of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"phi_t + underbraceboldsymbolu cdot nabla phi_substacktextadvection  textterm + underbracev nabla phi_substacktextnormal  textterm + underbraceb kappa nabla phi_substacktextcurvature  textterm + underbracetextsign(phi)(nabla phi - 1)_substacktextreinitialization textterm = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"phi  mathbbR^d times mathbbR^+ to mathbbR is the level set function\nboldsymbolu mathbbR^d times mathbbR^+  to mathbbR^d is a given (external) velocity field\nv  mathbbR^d times mathbbR^+ to mathbbR is a normal speed\nb  mathbbR^d times mathbbR^+ to mathbbR is a function that multiplies the curvature kappa = nabla cdot (nabla phi  nabla phi)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is how it looks in practice to create a simple LevelSetEquation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LevelSetMethods\ngrid = CartesianGrid((-1, -1), (1, 1), (100, 100))\n# œï    = LevelSet(x -> sqrt(2*x[1]^2 + x[2]^2) - 1/2, grid) # a disk\nœï    = LevelSetMethods.dumbbell(grid) # a predefined shape\nùêÆ    = (x,t) -> (-x[2], x[1])\neq   = LevelSetEquation(;\n  terms = (AdvectionTerm(ùêÆ),),\n  levelset = œï,\n  bc = PeriodicBC()\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can easily plot the current state of your level set equation using the plot function from Makie:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie # loads the MakieExt from LevelSetMethods\nLevelSetMethods.set_makie_theme!() # optional theme customization\nplot(œï)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To step it in time, we can use the integrate! function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"integrate!(eq, 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will advance the solution up to t = 1, modifying œï in the process:","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(œï)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Creating an animation can be achieved by calling integrate! in a loop and saving the results to a file:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GLMakie\ntheme = LevelSetMethods.makie_theme()\nanim = with_theme(theme) do\n    obs = Observable(eq)\n    fig = Figure()\n    ax = Axis(fig[1, 1])\n    plot!(ax, obs)\n    framerate = 30\n    t0 = current_time(eq)\n    tf = t0 + œÄ\n    timestamps = range(t0, tf; step = 1 / framerate)\n    record(fig, joinpath(@__DIR__, \"ls_intro.gif\"), timestamps) do t_\n        integrate!(eq, t_)\n        return obs[] = eq\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is what the .gif file looks like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Dumbbell)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more interesting applications and advanced usage, see the examples section!","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Other resources\nThere is an almost one-to-one correspondance between each of the LevelSetTerms described above and individual chapters of the book by Osher and Fedwick on level set methods [1], so users interested in digging deeper into the theory/algorithms are encourage to consult that refenrence. We also drew some inspiration from the great Matlab library ToolboxLS by Ian Mitchell [2].","category":"page"},{"location":"#Going-further","page":"Home","title":"Going further","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As illustrated above, the LevelSetEquation type is the main structure of this package. Becoming familiar with its fields and methods is a good starting point to use the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"LevelSetEquation","category":"page"},{"location":"#LevelSetMethods.LevelSetEquation","page":"Home","title":"LevelSetMethods.LevelSetEquation","text":"LevelSetEquation(; terms, levelset, boundary_conditions, t = 0, integrator = RK3())\n\nCreate a of a level-set equation of the form œï‚Çú + sum(terms) = 0, where each t ‚àà terms is a LevelSetTerm and levelset is the initial LevelSet.\n\nCalling integrate!(ls, tf) will evolve the level-set equation up to time tf, modifying the current_state(eq) and current_time(eq) of the object eq in the process (and therefore the original levelset).\n\nBoundary conditions can be specified in two ways. If a single BoundaryCondition is provided, it will be applied uniformly to all boundaries of the domain. To apply different boundary conditions to each boundary, pass a tuple of the form (bc_x, bc_y, ...) with as many elements as dimensions in the domain. If bc_x is a BoundaryCondition, it will be applied to both boundaries in the x direction. If bc_x is a tuple of two BoundaryConditions, the first will be applied to the left boundary and the second to the right boundary. The same logic applies to the other dimensions.\n\nThe optional parameter t specifies the initial time of the simulation, and integrator is the TimeIntegrator used to evolve the level-set equation.\n\nusing LevelSetMethods, StaticArrays\ngrid = CartesianGrid((-1, -1), (1, 1), (50, 50))    # define the grid\nœï = LevelSet(x -> x[1]^2 + x[2]^2 - 0.5^2, grid)    # initial shape\nùêÆ = MeshField(x -> SVector(1, 0), grid)             # advection velocity\nterms = (AdvectionTerm(ùêÆ),)            # advection and curvature terms\nbc = PeriodicBC()                                   # periodic boundary conditions\neq = LevelSetEquation(; terms, levelset = œï, bc)    # level-set equation\n\n# output\n\nLevel-set equation given by\n\n \t œï‚Çú + ùêÆ ‚ãÖ ‚àá œï = 0\n\nCurrent time 0.0\n\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"To learn more about the package, you should also check out the following sections:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The section on terms for a detailed description of each term and their corresponding customizations\nThe section on time integrators for a description of the available time integrators and how to use them\nThe section on boundary conditions for a description of the available boundary conditions and how to use them","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the examples section contains a list of examples that demonstrate some hopefully cool applications.","category":"page"},{"location":"#Bibliography","page":"Home","title":"Bibliography","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"S.¬†Osher and R.¬†Fedkiw. Level Set Methods and Dynamic Implicit Surfaces. Vol.¬†153 (Springer New York, New York, NY, 2003).\n\n\n\nI.¬†M.¬†Mitchell and others. A toolbox of level set methods. UBC¬†Department¬†of¬†Computer¬†Science¬†Technical¬†Report¬†TR-2007-11 1, 6 (2007).\n\n\n\nG.¬†Allaire, F.¬†Jouve and A.-M.¬†Toader. Structural optimization using sensitivity analysis and a level-set method. Journal¬†of¬†computational¬†physics 194, 363‚Äì393 (2004).\n\n\n\n","category":"page"},{"location":"example-shape-optim/#example-shape-optim","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"","category":"section"},{"location":"example-shape-optim/#Isoperimetric-inequality-as-a-shape-optimization-problem","page":"Shape optimization: a primer","title":"Isoperimetric inequality as a shape optimization problem","text":"","category":"section"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"We consider in this example the isoperimetric inequality which states that among all closed surfaces enclosing a fixed area with volume V_0  0, the sphere is the one with minimal perimeter. We show here how to demonstrate this result through numerical optimization.","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"warning: Warning\nThis example is purely illustrative. The optimization method used here has not been extensively tested. Coupling the LevelSetMethods toolbox to any simulation package makes it possible to solve PDE-constrained optimization problems (see for instance [3]).","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"To do this, we first define the problem mathematically:","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"    beginarrayrl\n        displaystylemin_Omega subset mathbbR^d  P(Omega)\n        \n        textuc  V(Omega) = V_0\n    endarrayqquadtext(1)","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"where P(Omega) V(Omega) are the perimeter and volume of Omega defined by","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"    V(Omega) = int_Omega textdmathbfx\n    quadtextandquad\n    P(Omega) = int_partial Omega textdmathbfs\n    ","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"The optimization problem text(1) can be solved using the augmented Lagrangian approach by minimizing iteratively the following functional:","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"    f(Omega) = P(Omega) + lambda (V(Omega) - V_0) + fracmu2 (V(Omega) - V_0)^2\n    qquadtext(2)","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"where mu is a parameter updated during the course of the optimization. To minimize text(2), we use a gradient-based algorithm. For this, we need to define what a small variation of Omega is. As such, for any shape Omega subset mathbbR^d we define (following Hadamard method) its deformation Omega_boldsymboltheta by a small vector field boldsymboltheta in W^1infty(mathbbR^d mathbbR^d) as:","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"    Omega_boldsymboltheta\n    = (textId + boldsymboltheta)(Omega)\n    = mathbfx + boldsymboltheta(mathbfx) mathbfx in Omega","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"The following first-order Taylor expansion can then be obtained:","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"    f(Omega_boldsymboltheta)\n    =\n    f(Omega)\n    +\n    int_partial Omega\n    left(\n        kappa + (lambda + mu (V(Omega) - V_0))\n    right) boldsymboltheta cdot mathbfn\n    textdmathbfs\n    + o(boldsymboltheta)\n    ","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"In other words, using boldsymboltheta = - (kappa + (lambda + mu (V(Omega) - V_0))) mathbfn and a small enough coefficient tau  0, f(Omega_tauboldsymboltheta) is necessary smaller than f(Omega).","category":"page"},{"location":"example-shape-optim/#Numerical-solution-using-the-level-set-method","page":"Shape optimization: a primer","title":"Numerical solution using the level-set method","text":"","category":"section"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"If Omega is given by the level-set function phi_0  R^d to R then one associated with Omega_tauboldsymboltheta is given by phi(cdot tau) solution of","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"    partial_t phi - kappa nabla phi - (lambda + mu (V(Omega) - V_0)) nabla phi = 0","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"with phi(cdot t = 0) = phi_0. In practice, it is easier to deal with deformations of fixed amplitude s, i.e. taumathbftheta_L^infty = delta. The value of tau is therefore set at each iteration as tau = deltamathbftheta_L^infty.","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"This optimization method is implemented in the following Julia code:","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"using LevelSetMethods\nusing LinearAlgebra\n\na = (-1.0, -1.0)\nb = (+1.0, +1.0)\nn = (50, 50)\ngrid = CartesianGrid(a, b, n)\n\nœï = LevelSetMethods.star(grid)\n\nterm1 = NormalMotionTerm(MeshField(X -> 0.0, grid))\nterm2 = CurvatureTerm(MeshField(X -> -1.0, grid))\nterms = (term1, term2)\n\nbc = NeumannGradientBC()\nintegrator = ForwardEuler(0.5)\neq = LevelSetEquation(; terms, integrator, levelset = œï, t = 0, bc)\n\nusing GLMakie\n\nnit = 200\nanim = with_theme(LevelSetMethods.makie_theme()) do\n    Œª, Œº = 0.0, 0.1\n    c = 1.1\n    V0 = 0.5\n    R0 = sqrt(V0/œÄ)\n    P0 = 2œÄ*R0\n    Œ¥ = 0.25\n\n    eq.t = 0\n    obs = Observable(eq)\n    fig = Figure()\n    ax = Axis(fig[1, 1])\n    plot!(ax, obs)\n    arc!([0; 0], R0, 0, 2œÄ)\n\n    record(fig, joinpath(@__DIR__,\"optimization.gif\"), 1:nit) do it\n        P = LevelSetMethods.perimeter(œï)\n        V = LevelSetMethods.volume(œï)\n\n        term1 = NormalMotionTerm(MeshField(X -> -(Œª + Œº * (V - V0)), grid))\n        eq.terms = (term1, term2)\n\n        œÑ = Œ¥ * LevelSetMethods.compute_cfl(eq.terms, eq.state, eq.t)\n        integrate!(eq, eq.t + œÑ)\n\n        Œª += Œº * (V - V0)\n        Œº *= c\n        return obs[] = eq\n    end\nend","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"(Image: Optimization)","category":"page"},{"location":"example-shape-optim/","page":"Shape optimization: a primer","title":"Shape optimization: a primer","text":"Different values and updates for the lambda and mu coefficients can be used to control the extent to which the optimization focuses on minimizing the objective or satisfying the constraint. Taking a smaller time step can also limit the oscillations observed at the end of optimization.","category":"page"}]
}
