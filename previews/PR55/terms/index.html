<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Level-set terms ¬∑ LevelSetMethods.jl</title><meta name="title" content="Level-set terms ¬∑ LevelSetMethods.jl"/><meta property="og:title" content="Level-set terms ¬∑ LevelSetMethods.jl"/><meta property="twitter:title" content="Level-set terms ¬∑ LevelSetMethods.jl"/><meta name="description" content="Documentation for LevelSetMethods.jl."/><meta property="og:description" content="Documentation for LevelSetMethods.jl."/><meta property="twitter:description" content="Documentation for LevelSetMethods.jl."/><meta property="og:url" content="https://maltezfaria.github.io/LevelSetMethods.jl/terms/"/><meta property="twitter:url" content="https://maltezfaria.github.io/LevelSetMethods.jl/terms/"/><link rel="canonical" href="https://maltezfaria.github.io/LevelSetMethods.jl/terms/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LevelSetMethods.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Level-set terms</a><ul class="internal"><li><a class="tocitem" href="#advection"><span>Advection</span></a></li><li><a class="tocitem" href="#normal-motion"><span>Normal motion</span></a></li><li><a class="tocitem" href="#curvature"><span>Curvature motion</span></a></li><li><a class="tocitem" href="#reinitialization"><span>Reinitialization term</span></a></li></ul></li><li><a class="tocitem" href="../time-integrators/">Time integration</a></li><li><a class="tocitem" href="../boundary-conditions/">Boundary conditions</a></li><li><span class="tocitem">Extensions</span><ul><li><a class="tocitem" href="../extension-makie/">Makie extension</a></li><li><a class="tocitem" href="../extension-mmg/">MMG extension</a></li><li><a class="tocitem" href="../extension-interpolations/">Interpolations extension</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example-zalesak/">Zalesak disk</a></li><li><a class="tocitem" href="../example-shape-optim/">Shape optimization: a primer</a></li></ul></li><li><a class="tocitem" href="../95-reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Level-set terms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Level-set terms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maltezfaria/LevelSetMethods.jl/blob/main/docs/src/terms.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="terms"><a class="docs-heading-anchor" href="#terms">Level-set terms</a><a id="terms-1"></a><a class="docs-heading-anchor-permalink" href="#terms" title="Permalink"></a></h1><p>A level-set equation is given by</p><p class="math-container">\[  \phi_t + \sum_n \texttt{term}_n = 0\]</p><p>where each <span>$\texttt{term}_n$</span> is a <code>LevelSetTerm</code> object. The following terms are available:</p><pre><code class="language-julia hljs">using LevelSetMethods
subtypes(LevelSetMethods.LevelSetTerm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Any}:
 AdvectionTerm
 CurvatureTerm
 NormalMotionTerm
 ReinitializationTerm</code></pre><p>Here we investigate the meaning of each term, and how they can be used to model different phenomena.</p><h2 id="advection"><a class="docs-heading-anchor" href="#advection">Advection</a><a id="advection-1"></a><a class="docs-heading-anchor-permalink" href="#advection" title="Permalink"></a></h2><p>The simplest term is the advection term, which is given by</p><p class="math-container">\[  \mathbf{u} \cdot \nabla \phi\]</p><p>where <span>$\mathbf{u}$</span> is a velocity field. This term models the transport of the level-set by an <em>external</em> velocity field (see [<a href="../#osher2003level">1</a>, Chapter 3]). You can construct an advection term using the <code>AdvectionTerm</code> structure:</p><pre><code class="language-julia hljs">using LevelSetMethods, StaticArrays
grid = CartesianGrid((-1,-1), (1,1), (100, 100))
ùêÆ = MeshField(x -&gt; SVector(1,0), grid)
AdvectionTerm(ùêÆ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ùêÆ ‚ãÖ ‚àá œï</code></pre><p>In the example above we passed a <a href="../95-reference/#LevelSetMethods.MeshField"><code>MeshField</code></a> object to the <code>AdvectionTerm</code> constructor, meaning that the velocity field is simply a vector of values at each grid point. This is useful if your velocity field is time-independent, or if you only know it at grid points. Lets construct a level-set equation with an advection term:</p><pre><code class="language-julia hljs">œï‚ÇÄ = LevelSet(x -&gt; sqrt(x[1]^2 + x[2]^2) - 0.5, grid)
eq = LevelSetEquation(; terms = (AdvectionTerm(ùêÆ),), levelset = œï‚ÇÄ, bc = PeriodicBC())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Level-set equation given by

 	 œï‚Çú + ùêÆ ‚ãÖ ‚àá œï = 0

Current time 0.0</code></pre><p>To see how the advection term affects the level-set, we can solve the equation for a few time steps:</p><pre><code class="language-julia hljs">using GLMakie
LevelSetMethods.set_makie_theme!()
fig = Figure(; size = (1200, 300))
# create a 2 x 2 figure
for (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])
    I = CartesianIndices((2,2))[n]
    integrate!(eq, t)
    # ax = Axis(fig[I[1],I[2]])
    ax = Axis(fig[1,n], title = &quot;t = $t&quot;)
    plot!(ax, eq)
end
fig</code></pre><img src="324bb6e3.png" alt="Example block output"/><p>In the example above we see that the level-set is advected to the right. If we wanted to have instead a time-dependent velocity field, we could pass a function to the <code>AdvectionTerm</code>, and the velocity field would be computed at each time step. For example:</p><pre><code class="language-julia hljs">œï‚ÇÄ = LevelSet(x -&gt; sqrt(x[1]^2 + x[2]^2) - 0.5, grid)
eq = LevelSetEquation(; terms = (AdvectionTerm((x,t) -&gt; SVector(x[1]^2, 0)),), levelset = œï‚ÇÄ, bc = PeriodicBC())
fig = Figure(; size = (1200, 300))
# create a 2 x 2 figure
for (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])
    I = CartesianIndices((2,2))[n]
    integrate!(eq, t)
    ax = Axis(fig[1,n], title = &quot;t = $t&quot;)
    plot!(ax, eq)
end
fig</code></pre><img src="4224fdfd.png" alt="Example block output"/><p>Note that the velocity function must accept two arguments: the spatial coordinates <code>x</code>, which is an abstract vector of length <code>d</code>, and the time <code>t</code>. Furthermore, it should return a vector of length <code>d</code>.</p><p>Besides the velocity field, the <code>AdvectionTerm</code> constructor also accepts a <code>scheme</code> as a second argument to specify the discretization scheme. The available options are:</p><ul><li><code>Upwind()</code>: first-order upwind scheme</li><li><code>WENO5()</code>: fifth-order WENO scheme (default)</li></ul><p>The WENO scheme is more expensive but much more accurate and is usually preferable to the upwind scheme, which introduces significant numerical diffusion. To see their differences, let us compare both schemes for a purely rotational velocity field:</p><pre><code class="language-julia hljs">œï‚ÇÄ = LevelSetMethods.dumbbell(grid) # pre-defined level-set
ùêÆ  = MeshField(grid) do (x,y)
    SVector(-y, x)
end
eq_upwind = LevelSetEquation(; terms = AdvectionTerm(ùêÆ, Upwind()), levelset = deepcopy(œï‚ÇÄ), bc = PeriodicBC())
eq_weno   = LevelSetEquation(; terms = AdvectionTerm(ùêÆ), levelset  = deepcopy(œï‚ÇÄ), bc = PeriodicBC())
fig = Figure(size = (1000, 400))
ax = Axis(fig[1,1], title = &quot;Initial&quot;)
plot!(ax, eq_upwind)
# do half a revolution
tf = œÄ
ax = Axis(fig[1,2], title = &quot;Upwind (final time)&quot;)
integrate!(eq_upwind, tf)
plot!(ax, eq_upwind)
ax = Axis(fig[1,3], title = &quot;WENO5 (final time)&quot;)
integrate!(eq_weno, tf)
plot!(ax, eq_weno)
fig</code></pre><img src="f41333e7.png" alt="Example block output"/><h2 id="normal-motion"><a class="docs-heading-anchor" href="#normal-motion">Normal motion</a><a id="normal-motion-1"></a><a class="docs-heading-anchor-permalink" href="#normal-motion" title="Permalink"></a></h2><p>The normal motion term is given by</p><p class="math-container">\[  v |\nabla \phi|\]</p><p>where <span>$v$</span> is a scalar field. This term models the motion of the level-set in the normal direction (see [<a href="../#osher2003level">1</a>, Chapter 6]). Here is an example of how to use it:</p><pre><code class="language-julia hljs">using LevelSetMethods
using GLMakie
grid = CartesianGrid((-2,-2), (2,2), (100, 100))
œï = LevelSetMethods.star(grid)
eq = LevelSetEquation(; terms = (NormalMotionTerm((x,t) -&gt; 0.5),), levelset = œï, bc = PeriodicBC())
fig = Figure(; size = (1200, 300))
for (n,t) in enumerate([0.0, 0.5, 0.75, 1.0])
    integrate!(eq, t)
    ax = Axis(fig[1,n], title = &quot;t = $t&quot;)
    plot!(ax, eq)
end
fig</code></pre><img src="ad9a5798.png" alt="Example block output"/><h2 id="curvature"><a class="docs-heading-anchor" href="#curvature">Curvature motion</a><a id="curvature-1"></a><a class="docs-heading-anchor-permalink" href="#curvature" title="Permalink"></a></h2><p>This terms models the motion of the level-set in the normal direction with a velocity that is proportional to the mean curvature:</p><p class="math-container">\[  b \kappa |\nabla \phi|\]</p><p>where <span>$\kappa = \nabla \cdot (\nabla \phi / |\nabla \phi|)$</span> is the mean curvature. Note that the coefficient <span>$b$</span> should be negative; a positive value of <span>$b$</span> would yield an ill-posed evolution problem (akin to a negative diffusion coefficient).</p><p>Here is the classic example of motion by mean curavature for a spiral-like level-set:</p><pre><code class="language-julia hljs">using LevelSetMethods, GLMakie
grid = CartesianGrid((-1,-1), (1,1), (100, 100))
# create a spiral level-set
d = 1
r0 = 0.5
Œ∏0 = -œÄ / 3
Œ± = œÄ / 100.0
R = [cos(Œ±) -sin(Œ±); sin(Œ±) cos(Œ±)]
M = R * [1/0.06^2 0; 0 1/(4œÄ^2)] * R&#39;
œï = LevelSet(grid) do (x, y)
    r = sqrt(x^2 + y^2)
    Œ∏ = atan(y, x)
    result = 1e30
    for i in 0:4
        Œ∏1 = Œ∏ + (2i - 4) * œÄ
        v = [r - r0; Œ∏1 - Œ∏0]
        result = min(result, sqrt(v&#39; * M * v) - d)
    end
    return result
end
eq = LevelSetEquation(; terms = (CurvatureTerm((x,t) -&gt; -0.1),), levelset = œï, bc = PeriodicBC())
fig = Figure(; size = (1200, 300))
for (n,t) in enumerate([0.0, 0.1, 0.2, 0.3])
    integrate!(eq, t)
    ax = Axis(fig[1,n], title = &quot;t = $t&quot;)
    plot!(ax, eq)
end
fig</code></pre><img src="f095f4ae.png" alt="Example block output"/><h2 id="reinitialization"><a class="docs-heading-anchor" href="#reinitialization">Reinitialization term</a><a id="reinitialization-1"></a><a class="docs-heading-anchor-permalink" href="#reinitialization" title="Permalink"></a></h2><p>The reinitialization term is given by</p><p class="math-container">\[  \phi_t + \text{sign}(\phi) \left( |\nabla \phi| - 1 \right) = 0\]</p><p>This term is used to ensure that the level-set function remains close to a signed distance function, which is sometimes important for numerical stability. The idea of the evolution equation above is to penalize the deviation of the level-set from a signed distance function, where <span>$|\nabla \phi| = 1$</span>, without changing the zero level-set. In practice a smeared <code>sign</code> function is used; see [<a href="../#osher2003level">1</a>, Chapter 7] for more details.</p><p>Here is an example of how to use the reinitialization term to obtain a signed distance function from a level-set. Let us first create a level-set that is not a signed distance, and its signed distance function:</p><pre><code class="language-julia hljs">using LevelSetMethods, GLMakie
grid = CartesianGrid((-1,-1), (1,1), (100, 100))
œï = LevelSet(x -&gt; x[1]^2 + x[2]^2 - 0.5^2, grid) # circle level-set, but not a signed distance function
sdf = LevelSet(x -&gt; sqrt(x[1]^2 + x[2]^2) - 0.5, grid) # signed distance function
LevelSetMethods.set_makie_theme!()
fig = Figure(; size = (800, 400))
ax = Axis(fig[1,1], title = &quot;Signed distance function&quot;)
contour!(ax, sdf; levels = [0.25, 0, 0.5], labels = true, labelsize = 14)
ax = Axis(fig[1,2], title = &quot;œï at t = 0&quot;)
contour!(ax, œï, levels = [0.25, 0, 0.5], labels = true, labelsize = 14)
fig</code></pre><img src="8a28d119.png" alt="Example block output"/><p>We will now evolve the level-set using the reinitialization term:</p><pre><code class="language-julia hljs">eq = LevelSetEquation(; terms = (ReinitializationTerm(),), levelset = deepcopy(œï), bc = PeriodicBC())
fig = Figure(; size = (1200, 300))
for (n,t) in enumerate([0.0, 0.25, 0.5, 0.75])
    integrate!(eq, t)
    ax = Axis(fig[1,n], title = &quot;t = $t&quot;)
    contour!(ax, LevelSetMethods.current_state(eq); levels = [0.25, 0, 0.5], labels = true, labelsize = 14)
end
fig</code></pre><img src="0b417651.png" alt="Example block output"/><p>Observe that as the reinitialization equation evolves, <code>œï</code> approaches the signed distance function <code>sdf</code> depicted in the first figure.</p><p>Alternatively, you can use a modified reinitialization term that applies the sign function to the <em>initial level-set function</em> only:</p><p class="math-container">\[  \phi_t + \text{sign}(\phi_0) \left( |\nabla \phi| - 1 \right) = 0\]</p><p>To enable this behavior, simply pass a <code>LevelSet</code> object to the <code>ReinitializationTerm</code>:</p><pre><code class="language-julia hljs">eq = LevelSetEquation(; terms = (ReinitializationTerm(œï),), levelset = deepcopy(œï), bc = PeriodicBC())
fig = Figure(; size = (1200, 300))
for (n,t) in enumerate([0.0, 0.25, 0.5, 0.75])
    integrate!(eq, t)
    ax = Axis(fig[1,n], title = &quot;t = $t&quot;)
    contour!(ax, LevelSetMethods.current_state(eq); levels = [0.25, 0, 0.5], labels = true, labelsize = 14)
end
fig</code></pre><img src="fea46f71.png" alt="Example block output"/><p>The outcome closely matches that of the previous approach.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><a class="docs-footer-nextpage" href="../time-integrators/">Time integration ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Thursday 5 June 2025 12:04">Thursday 5 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
